// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package order_service_test

//go:generate minimock -i route256/loms/internal/domain/order/order_service.OrderRepository -o order_repository_mock_test.go -n OrderRepositoryMock -p order_service_test

import (
	"context"
	"route256/loms/internal/domain/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// OrderRepositoryMock implements OrderRepository
type OrderRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, model *model.CreateOrderModel) (i1 int64, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, model *model.CreateOrderModel)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mOrderRepositoryMockCreate

	funcGetById          func(ctx context.Context, orderId int64) (op1 *model.OrderModel, err error)
	funcGetByIdOrigin    string
	inspectFuncGetById   func(ctx context.Context, orderId int64)
	afterGetByIdCounter  uint64
	beforeGetByIdCounter uint64
	GetByIdMock          mOrderRepositoryMockGetById

	funcUpdateStatus          func(ctx context.Context, orderId int64, status string, expectStatus string) (err error)
	funcUpdateStatusOrigin    string
	inspectFuncUpdateStatus   func(ctx context.Context, orderId int64, status string, expectStatus string)
	afterUpdateStatusCounter  uint64
	beforeUpdateStatusCounter uint64
	UpdateStatusMock          mOrderRepositoryMockUpdateStatus
}

// NewOrderRepositoryMock returns a mock for OrderRepository
func NewOrderRepositoryMock(t minimock.Tester) *OrderRepositoryMock {
	m := &OrderRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mOrderRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*OrderRepositoryMockCreateParams{}

	m.GetByIdMock = mOrderRepositoryMockGetById{mock: m}
	m.GetByIdMock.callArgs = []*OrderRepositoryMockGetByIdParams{}

	m.UpdateStatusMock = mOrderRepositoryMockUpdateStatus{mock: m}
	m.UpdateStatusMock.callArgs = []*OrderRepositoryMockUpdateStatusParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderRepositoryMockCreate struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockCreateExpectation
	expectations       []*OrderRepositoryMockCreateExpectation

	callArgs []*OrderRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockCreateExpectation specifies expectation struct of the OrderRepository.Create
type OrderRepositoryMockCreateExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockCreateParams
	paramPtrs          *OrderRepositoryMockCreateParamPtrs
	expectationOrigins OrderRepositoryMockCreateExpectationOrigins
	results            *OrderRepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockCreateParams contains parameters of the OrderRepository.Create
type OrderRepositoryMockCreateParams struct {
	ctx   context.Context
	model *model.CreateOrderModel
}

// OrderRepositoryMockCreateParamPtrs contains pointers to parameters of the OrderRepository.Create
type OrderRepositoryMockCreateParamPtrs struct {
	ctx   *context.Context
	model **model.CreateOrderModel
}

// OrderRepositoryMockCreateResults contains results of the OrderRepository.Create
type OrderRepositoryMockCreateResults struct {
	i1  int64
	err error
}

// OrderRepositoryMockCreateOrigins contains origins of expectations of the OrderRepository.Create
type OrderRepositoryMockCreateExpectationOrigins struct {
	origin      string
	originCtx   string
	originModel string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mOrderRepositoryMockCreate) Optional() *mOrderRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for OrderRepository.Create
func (mmCreate *mOrderRepositoryMockCreate) Expect(ctx context.Context, model *model.CreateOrderModel) *mOrderRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("OrderRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &OrderRepositoryMockCreateParams{ctx, model}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.Create
func (mmCreate *mOrderRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OrderRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OrderRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectModelParam2 sets up expected param model for OrderRepository.Create
func (mmCreate *mOrderRepositoryMockCreate) ExpectModelParam2(model *model.CreateOrderModel) *mOrderRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OrderRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OrderRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.model = &model
	mmCreate.defaultExpectation.expectationOrigins.originModel = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.Create
func (mmCreate *mOrderRepositoryMockCreate) Inspect(f func(ctx context.Context, model *model.CreateOrderModel)) *mOrderRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by OrderRepository.Create
func (mmCreate *mOrderRepositoryMockCreate) Return(i1 int64, err error) *OrderRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &OrderRepositoryMockCreateResults{i1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the OrderRepository.Create method
func (mmCreate *mOrderRepositoryMockCreate) Set(f func(ctx context.Context, model *model.CreateOrderModel) (i1 int64, err error)) *OrderRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the OrderRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the OrderRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the OrderRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mOrderRepositoryMockCreate) When(ctx context.Context, model *model.CreateOrderModel) *OrderRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderRepositoryMock.Create mock is already set by Set")
	}

	expectation := &OrderRepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &OrderRepositoryMockCreateParams{ctx, model},
		expectationOrigins: OrderRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.Create return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockCreateExpectation) Then(i1 int64, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times OrderRepository.Create should be invoked
func (mmCreate *mOrderRepositoryMockCreate) Times(n uint64) *mOrderRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of OrderRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mOrderRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements OrderRepository
func (mmCreate *OrderRepositoryMock) Create(ctx context.Context, model *model.CreateOrderModel) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, model)
	}

	mm_params := OrderRepositoryMockCreateParams{ctx, model}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockCreateParams{ctx, model}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("OrderRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.model != nil && !minimock.Equal(*mm_want_ptrs.model, mm_got.model) {
				mmCreate.t.Errorf("OrderRepositoryMock.Create got unexpected parameter model, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originModel, *mm_want_ptrs.model, mm_got.model, minimock.Diff(*mm_want_ptrs.model, mm_got.model))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("OrderRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the OrderRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, model)
	}
	mmCreate.t.Fatalf("Unexpected call to OrderRepositoryMock.Create. %v %v", ctx, model)
	return
}

// CreateAfterCounter returns a count of finished OrderRepositoryMock.Create invocations
func (mmCreate *OrderRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of OrderRepositoryMock.Create invocations
func (mmCreate *OrderRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mOrderRepositoryMockCreate) Calls() []*OrderRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mOrderRepositoryMockGetById struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockGetByIdExpectation
	expectations       []*OrderRepositoryMockGetByIdExpectation

	callArgs []*OrderRepositoryMockGetByIdParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockGetByIdExpectation specifies expectation struct of the OrderRepository.GetById
type OrderRepositoryMockGetByIdExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockGetByIdParams
	paramPtrs          *OrderRepositoryMockGetByIdParamPtrs
	expectationOrigins OrderRepositoryMockGetByIdExpectationOrigins
	results            *OrderRepositoryMockGetByIdResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockGetByIdParams contains parameters of the OrderRepository.GetById
type OrderRepositoryMockGetByIdParams struct {
	ctx     context.Context
	orderId int64
}

// OrderRepositoryMockGetByIdParamPtrs contains pointers to parameters of the OrderRepository.GetById
type OrderRepositoryMockGetByIdParamPtrs struct {
	ctx     *context.Context
	orderId *int64
}

// OrderRepositoryMockGetByIdResults contains results of the OrderRepository.GetById
type OrderRepositoryMockGetByIdResults struct {
	op1 *model.OrderModel
	err error
}

// OrderRepositoryMockGetByIdOrigins contains origins of expectations of the OrderRepository.GetById
type OrderRepositoryMockGetByIdExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetById *mOrderRepositoryMockGetById) Optional() *mOrderRepositoryMockGetById {
	mmGetById.optional = true
	return mmGetById
}

// Expect sets up expected params for OrderRepository.GetById
func (mmGetById *mOrderRepositoryMockGetById) Expect(ctx context.Context, orderId int64) *mOrderRepositoryMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("OrderRepositoryMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &OrderRepositoryMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.paramPtrs != nil {
		mmGetById.mock.t.Fatalf("OrderRepositoryMock.GetById mock is already set by ExpectParams functions")
	}

	mmGetById.defaultExpectation.params = &OrderRepositoryMockGetByIdParams{ctx, orderId}
	mmGetById.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetById.expectations {
		if minimock.Equal(e.params, mmGetById.defaultExpectation.params) {
			mmGetById.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetById.defaultExpectation.params)
		}
	}

	return mmGetById
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.GetById
func (mmGetById *mOrderRepositoryMockGetById) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("OrderRepositoryMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &OrderRepositoryMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.params != nil {
		mmGetById.mock.t.Fatalf("OrderRepositoryMock.GetById mock is already set by Expect")
	}

	if mmGetById.defaultExpectation.paramPtrs == nil {
		mmGetById.defaultExpectation.paramPtrs = &OrderRepositoryMockGetByIdParamPtrs{}
	}
	mmGetById.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetById.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetById
}

// ExpectOrderIdParam2 sets up expected param orderId for OrderRepository.GetById
func (mmGetById *mOrderRepositoryMockGetById) ExpectOrderIdParam2(orderId int64) *mOrderRepositoryMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("OrderRepositoryMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &OrderRepositoryMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.params != nil {
		mmGetById.mock.t.Fatalf("OrderRepositoryMock.GetById mock is already set by Expect")
	}

	if mmGetById.defaultExpectation.paramPtrs == nil {
		mmGetById.defaultExpectation.paramPtrs = &OrderRepositoryMockGetByIdParamPtrs{}
	}
	mmGetById.defaultExpectation.paramPtrs.orderId = &orderId
	mmGetById.defaultExpectation.expectationOrigins.originOrderId = minimock.CallerInfo(1)

	return mmGetById
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.GetById
func (mmGetById *mOrderRepositoryMockGetById) Inspect(f func(ctx context.Context, orderId int64)) *mOrderRepositoryMockGetById {
	if mmGetById.mock.inspectFuncGetById != nil {
		mmGetById.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetById")
	}

	mmGetById.mock.inspectFuncGetById = f

	return mmGetById
}

// Return sets up results that will be returned by OrderRepository.GetById
func (mmGetById *mOrderRepositoryMockGetById) Return(op1 *model.OrderModel, err error) *OrderRepositoryMock {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("OrderRepositoryMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &OrderRepositoryMockGetByIdExpectation{mock: mmGetById.mock}
	}
	mmGetById.defaultExpectation.results = &OrderRepositoryMockGetByIdResults{op1, err}
	mmGetById.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetById.mock
}

// Set uses given function f to mock the OrderRepository.GetById method
func (mmGetById *mOrderRepositoryMockGetById) Set(f func(ctx context.Context, orderId int64) (op1 *model.OrderModel, err error)) *OrderRepositoryMock {
	if mmGetById.defaultExpectation != nil {
		mmGetById.mock.t.Fatalf("Default expectation is already set for the OrderRepository.GetById method")
	}

	if len(mmGetById.expectations) > 0 {
		mmGetById.mock.t.Fatalf("Some expectations are already set for the OrderRepository.GetById method")
	}

	mmGetById.mock.funcGetById = f
	mmGetById.mock.funcGetByIdOrigin = minimock.CallerInfo(1)
	return mmGetById.mock
}

// When sets expectation for the OrderRepository.GetById which will trigger the result defined by the following
// Then helper
func (mmGetById *mOrderRepositoryMockGetById) When(ctx context.Context, orderId int64) *OrderRepositoryMockGetByIdExpectation {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("OrderRepositoryMock.GetById mock is already set by Set")
	}

	expectation := &OrderRepositoryMockGetByIdExpectation{
		mock:               mmGetById.mock,
		params:             &OrderRepositoryMockGetByIdParams{ctx, orderId},
		expectationOrigins: OrderRepositoryMockGetByIdExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetById.expectations = append(mmGetById.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.GetById return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetByIdExpectation) Then(op1 *model.OrderModel, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockGetByIdResults{op1, err}
	return e.mock
}

// Times sets number of times OrderRepository.GetById should be invoked
func (mmGetById *mOrderRepositoryMockGetById) Times(n uint64) *mOrderRepositoryMockGetById {
	if n == 0 {
		mmGetById.mock.t.Fatalf("Times of OrderRepositoryMock.GetById mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetById.expectedInvocations, n)
	mmGetById.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetById
}

func (mmGetById *mOrderRepositoryMockGetById) invocationsDone() bool {
	if len(mmGetById.expectations) == 0 && mmGetById.defaultExpectation == nil && mmGetById.mock.funcGetById == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetById.mock.afterGetByIdCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetById.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetById implements OrderRepository
func (mmGetById *OrderRepositoryMock) GetById(ctx context.Context, orderId int64) (op1 *model.OrderModel, err error) {
	mm_atomic.AddUint64(&mmGetById.beforeGetByIdCounter, 1)
	defer mm_atomic.AddUint64(&mmGetById.afterGetByIdCounter, 1)

	mmGetById.t.Helper()

	if mmGetById.inspectFuncGetById != nil {
		mmGetById.inspectFuncGetById(ctx, orderId)
	}

	mm_params := OrderRepositoryMockGetByIdParams{ctx, orderId}

	// Record call args
	mmGetById.GetByIdMock.mutex.Lock()
	mmGetById.GetByIdMock.callArgs = append(mmGetById.GetByIdMock.callArgs, &mm_params)
	mmGetById.GetByIdMock.mutex.Unlock()

	for _, e := range mmGetById.GetByIdMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetById.GetByIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetById.GetByIdMock.defaultExpectation.Counter, 1)
		mm_want := mmGetById.GetByIdMock.defaultExpectation.params
		mm_want_ptrs := mmGetById.GetByIdMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockGetByIdParams{ctx, orderId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetById.t.Errorf("OrderRepositoryMock.GetById got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetById.GetByIdMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderId != nil && !minimock.Equal(*mm_want_ptrs.orderId, mm_got.orderId) {
				mmGetById.t.Errorf("OrderRepositoryMock.GetById got unexpected parameter orderId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetById.GetByIdMock.defaultExpectation.expectationOrigins.originOrderId, *mm_want_ptrs.orderId, mm_got.orderId, minimock.Diff(*mm_want_ptrs.orderId, mm_got.orderId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetById.t.Errorf("OrderRepositoryMock.GetById got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetById.GetByIdMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetById.GetByIdMock.defaultExpectation.results
		if mm_results == nil {
			mmGetById.t.Fatal("No results are set for the OrderRepositoryMock.GetById")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetById.funcGetById != nil {
		return mmGetById.funcGetById(ctx, orderId)
	}
	mmGetById.t.Fatalf("Unexpected call to OrderRepositoryMock.GetById. %v %v", ctx, orderId)
	return
}

// GetByIdAfterCounter returns a count of finished OrderRepositoryMock.GetById invocations
func (mmGetById *OrderRepositoryMock) GetByIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetById.afterGetByIdCounter)
}

// GetByIdBeforeCounter returns a count of OrderRepositoryMock.GetById invocations
func (mmGetById *OrderRepositoryMock) GetByIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetById.beforeGetByIdCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetById.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetById *mOrderRepositoryMockGetById) Calls() []*OrderRepositoryMockGetByIdParams {
	mmGetById.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockGetByIdParams, len(mmGetById.callArgs))
	copy(argCopy, mmGetById.callArgs)

	mmGetById.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIdDone returns true if the count of the GetById invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetByIdDone() bool {
	if m.GetByIdMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByIdMock.invocationsDone()
}

// MinimockGetByIdInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetByIdInspect() {
	for _, e := range m.GetByIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetById at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByIdCounter := mm_atomic.LoadUint64(&m.afterGetByIdCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIdMock.defaultExpectation != nil && afterGetByIdCounter < 1 {
		if m.GetByIdMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetById at\n%s", m.GetByIdMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetById at\n%s with params: %#v", m.GetByIdMock.defaultExpectation.expectationOrigins.origin, *m.GetByIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetById != nil && afterGetByIdCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.GetById at\n%s", m.funcGetByIdOrigin)
	}

	if !m.GetByIdMock.invocationsDone() && afterGetByIdCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.GetById at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByIdMock.expectedInvocations), m.GetByIdMock.expectedInvocationsOrigin, afterGetByIdCounter)
	}
}

type mOrderRepositoryMockUpdateStatus struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockUpdateStatusExpectation
	expectations       []*OrderRepositoryMockUpdateStatusExpectation

	callArgs []*OrderRepositoryMockUpdateStatusParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockUpdateStatusExpectation specifies expectation struct of the OrderRepository.UpdateStatus
type OrderRepositoryMockUpdateStatusExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockUpdateStatusParams
	paramPtrs          *OrderRepositoryMockUpdateStatusParamPtrs
	expectationOrigins OrderRepositoryMockUpdateStatusExpectationOrigins
	results            *OrderRepositoryMockUpdateStatusResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockUpdateStatusParams contains parameters of the OrderRepository.UpdateStatus
type OrderRepositoryMockUpdateStatusParams struct {
	ctx          context.Context
	orderId      int64
	status       string
	expectStatus string
}

// OrderRepositoryMockUpdateStatusParamPtrs contains pointers to parameters of the OrderRepository.UpdateStatus
type OrderRepositoryMockUpdateStatusParamPtrs struct {
	ctx          *context.Context
	orderId      *int64
	status       *string
	expectStatus *string
}

// OrderRepositoryMockUpdateStatusResults contains results of the OrderRepository.UpdateStatus
type OrderRepositoryMockUpdateStatusResults struct {
	err error
}

// OrderRepositoryMockUpdateStatusOrigins contains origins of expectations of the OrderRepository.UpdateStatus
type OrderRepositoryMockUpdateStatusExpectationOrigins struct {
	origin             string
	originCtx          string
	originOrderId      string
	originStatus       string
	originExpectStatus string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateStatus *mOrderRepositoryMockUpdateStatus) Optional() *mOrderRepositoryMockUpdateStatus {
	mmUpdateStatus.optional = true
	return mmUpdateStatus
}

// Expect sets up expected params for OrderRepository.UpdateStatus
func (mmUpdateStatus *mOrderRepositoryMockUpdateStatus) Expect(ctx context.Context, orderId int64, status string, expectStatus string) *mOrderRepositoryMockUpdateStatus {
	if mmUpdateStatus.mock.funcUpdateStatus != nil {
		mmUpdateStatus.mock.t.Fatalf("OrderRepositoryMock.UpdateStatus mock is already set by Set")
	}

	if mmUpdateStatus.defaultExpectation == nil {
		mmUpdateStatus.defaultExpectation = &OrderRepositoryMockUpdateStatusExpectation{}
	}

	if mmUpdateStatus.defaultExpectation.paramPtrs != nil {
		mmUpdateStatus.mock.t.Fatalf("OrderRepositoryMock.UpdateStatus mock is already set by ExpectParams functions")
	}

	mmUpdateStatus.defaultExpectation.params = &OrderRepositoryMockUpdateStatusParams{ctx, orderId, status, expectStatus}
	mmUpdateStatus.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateStatus.expectations {
		if minimock.Equal(e.params, mmUpdateStatus.defaultExpectation.params) {
			mmUpdateStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateStatus.defaultExpectation.params)
		}
	}

	return mmUpdateStatus
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.UpdateStatus
func (mmUpdateStatus *mOrderRepositoryMockUpdateStatus) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockUpdateStatus {
	if mmUpdateStatus.mock.funcUpdateStatus != nil {
		mmUpdateStatus.mock.t.Fatalf("OrderRepositoryMock.UpdateStatus mock is already set by Set")
	}

	if mmUpdateStatus.defaultExpectation == nil {
		mmUpdateStatus.defaultExpectation = &OrderRepositoryMockUpdateStatusExpectation{}
	}

	if mmUpdateStatus.defaultExpectation.params != nil {
		mmUpdateStatus.mock.t.Fatalf("OrderRepositoryMock.UpdateStatus mock is already set by Expect")
	}

	if mmUpdateStatus.defaultExpectation.paramPtrs == nil {
		mmUpdateStatus.defaultExpectation.paramPtrs = &OrderRepositoryMockUpdateStatusParamPtrs{}
	}
	mmUpdateStatus.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateStatus.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateStatus
}

// ExpectOrderIdParam2 sets up expected param orderId for OrderRepository.UpdateStatus
func (mmUpdateStatus *mOrderRepositoryMockUpdateStatus) ExpectOrderIdParam2(orderId int64) *mOrderRepositoryMockUpdateStatus {
	if mmUpdateStatus.mock.funcUpdateStatus != nil {
		mmUpdateStatus.mock.t.Fatalf("OrderRepositoryMock.UpdateStatus mock is already set by Set")
	}

	if mmUpdateStatus.defaultExpectation == nil {
		mmUpdateStatus.defaultExpectation = &OrderRepositoryMockUpdateStatusExpectation{}
	}

	if mmUpdateStatus.defaultExpectation.params != nil {
		mmUpdateStatus.mock.t.Fatalf("OrderRepositoryMock.UpdateStatus mock is already set by Expect")
	}

	if mmUpdateStatus.defaultExpectation.paramPtrs == nil {
		mmUpdateStatus.defaultExpectation.paramPtrs = &OrderRepositoryMockUpdateStatusParamPtrs{}
	}
	mmUpdateStatus.defaultExpectation.paramPtrs.orderId = &orderId
	mmUpdateStatus.defaultExpectation.expectationOrigins.originOrderId = minimock.CallerInfo(1)

	return mmUpdateStatus
}

// ExpectStatusParam3 sets up expected param status for OrderRepository.UpdateStatus
func (mmUpdateStatus *mOrderRepositoryMockUpdateStatus) ExpectStatusParam3(status string) *mOrderRepositoryMockUpdateStatus {
	if mmUpdateStatus.mock.funcUpdateStatus != nil {
		mmUpdateStatus.mock.t.Fatalf("OrderRepositoryMock.UpdateStatus mock is already set by Set")
	}

	if mmUpdateStatus.defaultExpectation == nil {
		mmUpdateStatus.defaultExpectation = &OrderRepositoryMockUpdateStatusExpectation{}
	}

	if mmUpdateStatus.defaultExpectation.params != nil {
		mmUpdateStatus.mock.t.Fatalf("OrderRepositoryMock.UpdateStatus mock is already set by Expect")
	}

	if mmUpdateStatus.defaultExpectation.paramPtrs == nil {
		mmUpdateStatus.defaultExpectation.paramPtrs = &OrderRepositoryMockUpdateStatusParamPtrs{}
	}
	mmUpdateStatus.defaultExpectation.paramPtrs.status = &status
	mmUpdateStatus.defaultExpectation.expectationOrigins.originStatus = minimock.CallerInfo(1)

	return mmUpdateStatus
}

// ExpectExpectStatusParam4 sets up expected param expectStatus for OrderRepository.UpdateStatus
func (mmUpdateStatus *mOrderRepositoryMockUpdateStatus) ExpectExpectStatusParam4(expectStatus string) *mOrderRepositoryMockUpdateStatus {
	if mmUpdateStatus.mock.funcUpdateStatus != nil {
		mmUpdateStatus.mock.t.Fatalf("OrderRepositoryMock.UpdateStatus mock is already set by Set")
	}

	if mmUpdateStatus.defaultExpectation == nil {
		mmUpdateStatus.defaultExpectation = &OrderRepositoryMockUpdateStatusExpectation{}
	}

	if mmUpdateStatus.defaultExpectation.params != nil {
		mmUpdateStatus.mock.t.Fatalf("OrderRepositoryMock.UpdateStatus mock is already set by Expect")
	}

	if mmUpdateStatus.defaultExpectation.paramPtrs == nil {
		mmUpdateStatus.defaultExpectation.paramPtrs = &OrderRepositoryMockUpdateStatusParamPtrs{}
	}
	mmUpdateStatus.defaultExpectation.paramPtrs.expectStatus = &expectStatus
	mmUpdateStatus.defaultExpectation.expectationOrigins.originExpectStatus = minimock.CallerInfo(1)

	return mmUpdateStatus
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.UpdateStatus
func (mmUpdateStatus *mOrderRepositoryMockUpdateStatus) Inspect(f func(ctx context.Context, orderId int64, status string, expectStatus string)) *mOrderRepositoryMockUpdateStatus {
	if mmUpdateStatus.mock.inspectFuncUpdateStatus != nil {
		mmUpdateStatus.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.UpdateStatus")
	}

	mmUpdateStatus.mock.inspectFuncUpdateStatus = f

	return mmUpdateStatus
}

// Return sets up results that will be returned by OrderRepository.UpdateStatus
func (mmUpdateStatus *mOrderRepositoryMockUpdateStatus) Return(err error) *OrderRepositoryMock {
	if mmUpdateStatus.mock.funcUpdateStatus != nil {
		mmUpdateStatus.mock.t.Fatalf("OrderRepositoryMock.UpdateStatus mock is already set by Set")
	}

	if mmUpdateStatus.defaultExpectation == nil {
		mmUpdateStatus.defaultExpectation = &OrderRepositoryMockUpdateStatusExpectation{mock: mmUpdateStatus.mock}
	}
	mmUpdateStatus.defaultExpectation.results = &OrderRepositoryMockUpdateStatusResults{err}
	mmUpdateStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateStatus.mock
}

// Set uses given function f to mock the OrderRepository.UpdateStatus method
func (mmUpdateStatus *mOrderRepositoryMockUpdateStatus) Set(f func(ctx context.Context, orderId int64, status string, expectStatus string) (err error)) *OrderRepositoryMock {
	if mmUpdateStatus.defaultExpectation != nil {
		mmUpdateStatus.mock.t.Fatalf("Default expectation is already set for the OrderRepository.UpdateStatus method")
	}

	if len(mmUpdateStatus.expectations) > 0 {
		mmUpdateStatus.mock.t.Fatalf("Some expectations are already set for the OrderRepository.UpdateStatus method")
	}

	mmUpdateStatus.mock.funcUpdateStatus = f
	mmUpdateStatus.mock.funcUpdateStatusOrigin = minimock.CallerInfo(1)
	return mmUpdateStatus.mock
}

// When sets expectation for the OrderRepository.UpdateStatus which will trigger the result defined by the following
// Then helper
func (mmUpdateStatus *mOrderRepositoryMockUpdateStatus) When(ctx context.Context, orderId int64, status string, expectStatus string) *OrderRepositoryMockUpdateStatusExpectation {
	if mmUpdateStatus.mock.funcUpdateStatus != nil {
		mmUpdateStatus.mock.t.Fatalf("OrderRepositoryMock.UpdateStatus mock is already set by Set")
	}

	expectation := &OrderRepositoryMockUpdateStatusExpectation{
		mock:               mmUpdateStatus.mock,
		params:             &OrderRepositoryMockUpdateStatusParams{ctx, orderId, status, expectStatus},
		expectationOrigins: OrderRepositoryMockUpdateStatusExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateStatus.expectations = append(mmUpdateStatus.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.UpdateStatus return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockUpdateStatusExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockUpdateStatusResults{err}
	return e.mock
}

// Times sets number of times OrderRepository.UpdateStatus should be invoked
func (mmUpdateStatus *mOrderRepositoryMockUpdateStatus) Times(n uint64) *mOrderRepositoryMockUpdateStatus {
	if n == 0 {
		mmUpdateStatus.mock.t.Fatalf("Times of OrderRepositoryMock.UpdateStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateStatus.expectedInvocations, n)
	mmUpdateStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateStatus
}

func (mmUpdateStatus *mOrderRepositoryMockUpdateStatus) invocationsDone() bool {
	if len(mmUpdateStatus.expectations) == 0 && mmUpdateStatus.defaultExpectation == nil && mmUpdateStatus.mock.funcUpdateStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateStatus.mock.afterUpdateStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateStatus implements OrderRepository
func (mmUpdateStatus *OrderRepositoryMock) UpdateStatus(ctx context.Context, orderId int64, status string, expectStatus string) (err error) {
	mm_atomic.AddUint64(&mmUpdateStatus.beforeUpdateStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateStatus.afterUpdateStatusCounter, 1)

	mmUpdateStatus.t.Helper()

	if mmUpdateStatus.inspectFuncUpdateStatus != nil {
		mmUpdateStatus.inspectFuncUpdateStatus(ctx, orderId, status, expectStatus)
	}

	mm_params := OrderRepositoryMockUpdateStatusParams{ctx, orderId, status, expectStatus}

	// Record call args
	mmUpdateStatus.UpdateStatusMock.mutex.Lock()
	mmUpdateStatus.UpdateStatusMock.callArgs = append(mmUpdateStatus.UpdateStatusMock.callArgs, &mm_params)
	mmUpdateStatus.UpdateStatusMock.mutex.Unlock()

	for _, e := range mmUpdateStatus.UpdateStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateStatus.UpdateStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateStatus.UpdateStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateStatus.UpdateStatusMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateStatus.UpdateStatusMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockUpdateStatusParams{ctx, orderId, status, expectStatus}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateStatus.t.Errorf("OrderRepositoryMock.UpdateStatus got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateStatus.UpdateStatusMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderId != nil && !minimock.Equal(*mm_want_ptrs.orderId, mm_got.orderId) {
				mmUpdateStatus.t.Errorf("OrderRepositoryMock.UpdateStatus got unexpected parameter orderId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateStatus.UpdateStatusMock.defaultExpectation.expectationOrigins.originOrderId, *mm_want_ptrs.orderId, mm_got.orderId, minimock.Diff(*mm_want_ptrs.orderId, mm_got.orderId))
			}

			if mm_want_ptrs.status != nil && !minimock.Equal(*mm_want_ptrs.status, mm_got.status) {
				mmUpdateStatus.t.Errorf("OrderRepositoryMock.UpdateStatus got unexpected parameter status, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateStatus.UpdateStatusMock.defaultExpectation.expectationOrigins.originStatus, *mm_want_ptrs.status, mm_got.status, minimock.Diff(*mm_want_ptrs.status, mm_got.status))
			}

			if mm_want_ptrs.expectStatus != nil && !minimock.Equal(*mm_want_ptrs.expectStatus, mm_got.expectStatus) {
				mmUpdateStatus.t.Errorf("OrderRepositoryMock.UpdateStatus got unexpected parameter expectStatus, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateStatus.UpdateStatusMock.defaultExpectation.expectationOrigins.originExpectStatus, *mm_want_ptrs.expectStatus, mm_got.expectStatus, minimock.Diff(*mm_want_ptrs.expectStatus, mm_got.expectStatus))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateStatus.t.Errorf("OrderRepositoryMock.UpdateStatus got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateStatus.UpdateStatusMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateStatus.UpdateStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateStatus.t.Fatal("No results are set for the OrderRepositoryMock.UpdateStatus")
		}
		return (*mm_results).err
	}
	if mmUpdateStatus.funcUpdateStatus != nil {
		return mmUpdateStatus.funcUpdateStatus(ctx, orderId, status, expectStatus)
	}
	mmUpdateStatus.t.Fatalf("Unexpected call to OrderRepositoryMock.UpdateStatus. %v %v %v %v", ctx, orderId, status, expectStatus)
	return
}

// UpdateStatusAfterCounter returns a count of finished OrderRepositoryMock.UpdateStatus invocations
func (mmUpdateStatus *OrderRepositoryMock) UpdateStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStatus.afterUpdateStatusCounter)
}

// UpdateStatusBeforeCounter returns a count of OrderRepositoryMock.UpdateStatus invocations
func (mmUpdateStatus *OrderRepositoryMock) UpdateStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStatus.beforeUpdateStatusCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.UpdateStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateStatus *mOrderRepositoryMockUpdateStatus) Calls() []*OrderRepositoryMockUpdateStatusParams {
	mmUpdateStatus.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockUpdateStatusParams, len(mmUpdateStatus.callArgs))
	copy(argCopy, mmUpdateStatus.callArgs)

	mmUpdateStatus.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateStatusDone returns true if the count of the UpdateStatus invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockUpdateStatusDone() bool {
	if m.UpdateStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateStatusMock.invocationsDone()
}

// MinimockUpdateStatusInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockUpdateStatusInspect() {
	for _, e := range m.UpdateStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.UpdateStatus at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateStatusCounter := mm_atomic.LoadUint64(&m.afterUpdateStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateStatusMock.defaultExpectation != nil && afterUpdateStatusCounter < 1 {
		if m.UpdateStatusMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.UpdateStatus at\n%s", m.UpdateStatusMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.UpdateStatus at\n%s with params: %#v", m.UpdateStatusMock.defaultExpectation.expectationOrigins.origin, *m.UpdateStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateStatus != nil && afterUpdateStatusCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.UpdateStatus at\n%s", m.funcUpdateStatusOrigin)
	}

	if !m.UpdateStatusMock.invocationsDone() && afterUpdateStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.UpdateStatus at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateStatusMock.expectedInvocations), m.UpdateStatusMock.expectedInvocationsOrigin, afterUpdateStatusCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockGetByIdInspect()

			m.MinimockUpdateStatusInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockGetByIdDone() &&
		m.MinimockUpdateStatusDone()
}
