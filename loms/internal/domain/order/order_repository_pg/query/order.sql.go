// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: order.sql

package query

import (
	"context"
)

const createOrder = `-- name: CreateOrder :one
with create_order as (
    insert into orders (user_id, status)
    values ($1, $2)
    returning id, status, user_id
), insert_outbox as (
    insert into outbox (
        aggregate_id,
        aggregate_type,
        event_type,
        key,
        payload,
        topic,
        status
    )
    select
        co.id,
        'order',
        'order_status_updated',
        co.user_id::text,
        json_build_object(
            'from_status', '',
            'to_status', co.status,
            'order_id', co.id,
            'user_id', co.user_id
        ),
        $3,
        'pending'
    from create_order as co
)
select id from create_order
`

type CreateOrderParams struct {
	UserID int64
	Status string
	Topic  string
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (int64, error) {
	row := q.db.QueryRow(ctx, createOrder, arg.UserID, arg.Status, arg.Topic)
	var id int64
	err := row.Scan(&id)
	return id, err
}

type CreateOrderItemsParams struct {
	OrderID  int64
	Sku      int64
	Quantity int64
}

const getByID = `-- name: GetByID :many
select o.id,
    o.user_id,
    o.status,
    oi.sku,
    oi.quantity
from orders as o
    join order_items as oi on o.id = oi.order_id
where o.id = $1
order by oi.sku asc
`

type GetByIDRow struct {
	ID       int64
	UserID   int64
	Status   string
	Sku      int64
	Quantity int64
}

func (q *Queries) GetByID(ctx context.Context, id int64) ([]GetByIDRow, error) {
	rows, err := q.db.Query(ctx, getByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetByIDRow
	for rows.Next() {
		var i GetByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.Sku,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStatus = `-- name: UpdateStatus :one
with update_status as (
    update orders as o
    set status = $1,
        updated_at = now()
    where o.id = $2
        and o.status = $3
    returning id, status, user_id
), insert_outbox as (
    insert into outbox (
        aggregate_id,
        aggregate_type,
        event_type,
        key,
        payload,
        topic,
        status
    )
    select
        u.id,
        'order',
        'order_status_updated',
        u.user_id::text,
        json_build_object(
            'from_status', $3,
            'to_status', $1,
            'order_id', u.id,
            'user_id', u.user_id
        ),
        $4,
        'pending'
    from update_status as u
    where u.status not like '%ing'
)
select id
from update_status
`

type UpdateStatusParams struct {
	Status    string
	ID        int64
	OldStatus string
	Topic     string
}

func (q *Queries) UpdateStatus(ctx context.Context, arg UpdateStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateStatus,
		arg.Status,
		arg.ID,
		arg.OldStatus,
		arg.Topic,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}
