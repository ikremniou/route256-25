// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package service_test

//go:generate minimock -i route256/cart/internal/domain/cart/service.ProductService -o product_service_mock_test.go -n ProductServiceMock -p service_test

import (
	"context"
	"route256/cart/internal/domain/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ProductServiceMock implements ProductService
type ProductServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetProduct          func(ctx context.Context, skuId int64) (p1 model.ProductModel, err error)
	funcGetProductOrigin    string
	inspectFuncGetProduct   func(ctx context.Context, skuId int64)
	afterGetProductCounter  uint64
	beforeGetProductCounter uint64
	GetProductMock          mProductServiceMockGetProduct

	funcGetProductsAot          func(ctx context.Context, count int64, startSkuId int64) (pa1 []model.ProductModel, err error)
	funcGetProductsAotOrigin    string
	inspectFuncGetProductsAot   func(ctx context.Context, count int64, startSkuId int64)
	afterGetProductsAotCounter  uint64
	beforeGetProductsAotCounter uint64
	GetProductsAotMock          mProductServiceMockGetProductsAot

	funcIsProductExists          func(ctx context.Context, skuId int64) (b1 bool, err error)
	funcIsProductExistsOrigin    string
	inspectFuncIsProductExists   func(ctx context.Context, skuId int64)
	afterIsProductExistsCounter  uint64
	beforeIsProductExistsCounter uint64
	IsProductExistsMock          mProductServiceMockIsProductExists
}

// NewProductServiceMock returns a mock for ProductService
func NewProductServiceMock(t minimock.Tester) *ProductServiceMock {
	m := &ProductServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetProductMock = mProductServiceMockGetProduct{mock: m}
	m.GetProductMock.callArgs = []*ProductServiceMockGetProductParams{}

	m.GetProductsAotMock = mProductServiceMockGetProductsAot{mock: m}
	m.GetProductsAotMock.callArgs = []*ProductServiceMockGetProductsAotParams{}

	m.IsProductExistsMock = mProductServiceMockIsProductExists{mock: m}
	m.IsProductExistsMock.callArgs = []*ProductServiceMockIsProductExistsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mProductServiceMockGetProduct struct {
	optional           bool
	mock               *ProductServiceMock
	defaultExpectation *ProductServiceMockGetProductExpectation
	expectations       []*ProductServiceMockGetProductExpectation

	callArgs []*ProductServiceMockGetProductParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProductServiceMockGetProductExpectation specifies expectation struct of the ProductService.GetProduct
type ProductServiceMockGetProductExpectation struct {
	mock               *ProductServiceMock
	params             *ProductServiceMockGetProductParams
	paramPtrs          *ProductServiceMockGetProductParamPtrs
	expectationOrigins ProductServiceMockGetProductExpectationOrigins
	results            *ProductServiceMockGetProductResults
	returnOrigin       string
	Counter            uint64
}

// ProductServiceMockGetProductParams contains parameters of the ProductService.GetProduct
type ProductServiceMockGetProductParams struct {
	ctx   context.Context
	skuId int64
}

// ProductServiceMockGetProductParamPtrs contains pointers to parameters of the ProductService.GetProduct
type ProductServiceMockGetProductParamPtrs struct {
	ctx   *context.Context
	skuId *int64
}

// ProductServiceMockGetProductResults contains results of the ProductService.GetProduct
type ProductServiceMockGetProductResults struct {
	p1  model.ProductModel
	err error
}

// ProductServiceMockGetProductOrigins contains origins of expectations of the ProductService.GetProduct
type ProductServiceMockGetProductExpectationOrigins struct {
	origin      string
	originCtx   string
	originSkuId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetProduct *mProductServiceMockGetProduct) Optional() *mProductServiceMockGetProduct {
	mmGetProduct.optional = true
	return mmGetProduct
}

// Expect sets up expected params for ProductService.GetProduct
func (mmGetProduct *mProductServiceMockGetProduct) Expect(ctx context.Context, skuId int64) *mProductServiceMockGetProduct {
	if mmGetProduct.mock.funcGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("ProductServiceMock.GetProduct mock is already set by Set")
	}

	if mmGetProduct.defaultExpectation == nil {
		mmGetProduct.defaultExpectation = &ProductServiceMockGetProductExpectation{}
	}

	if mmGetProduct.defaultExpectation.paramPtrs != nil {
		mmGetProduct.mock.t.Fatalf("ProductServiceMock.GetProduct mock is already set by ExpectParams functions")
	}

	mmGetProduct.defaultExpectation.params = &ProductServiceMockGetProductParams{ctx, skuId}
	mmGetProduct.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetProduct.expectations {
		if minimock.Equal(e.params, mmGetProduct.defaultExpectation.params) {
			mmGetProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetProduct.defaultExpectation.params)
		}
	}

	return mmGetProduct
}

// ExpectCtxParam1 sets up expected param ctx for ProductService.GetProduct
func (mmGetProduct *mProductServiceMockGetProduct) ExpectCtxParam1(ctx context.Context) *mProductServiceMockGetProduct {
	if mmGetProduct.mock.funcGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("ProductServiceMock.GetProduct mock is already set by Set")
	}

	if mmGetProduct.defaultExpectation == nil {
		mmGetProduct.defaultExpectation = &ProductServiceMockGetProductExpectation{}
	}

	if mmGetProduct.defaultExpectation.params != nil {
		mmGetProduct.mock.t.Fatalf("ProductServiceMock.GetProduct mock is already set by Expect")
	}

	if mmGetProduct.defaultExpectation.paramPtrs == nil {
		mmGetProduct.defaultExpectation.paramPtrs = &ProductServiceMockGetProductParamPtrs{}
	}
	mmGetProduct.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetProduct.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetProduct
}

// ExpectSkuIdParam2 sets up expected param skuId for ProductService.GetProduct
func (mmGetProduct *mProductServiceMockGetProduct) ExpectSkuIdParam2(skuId int64) *mProductServiceMockGetProduct {
	if mmGetProduct.mock.funcGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("ProductServiceMock.GetProduct mock is already set by Set")
	}

	if mmGetProduct.defaultExpectation == nil {
		mmGetProduct.defaultExpectation = &ProductServiceMockGetProductExpectation{}
	}

	if mmGetProduct.defaultExpectation.params != nil {
		mmGetProduct.mock.t.Fatalf("ProductServiceMock.GetProduct mock is already set by Expect")
	}

	if mmGetProduct.defaultExpectation.paramPtrs == nil {
		mmGetProduct.defaultExpectation.paramPtrs = &ProductServiceMockGetProductParamPtrs{}
	}
	mmGetProduct.defaultExpectation.paramPtrs.skuId = &skuId
	mmGetProduct.defaultExpectation.expectationOrigins.originSkuId = minimock.CallerInfo(1)

	return mmGetProduct
}

// Inspect accepts an inspector function that has same arguments as the ProductService.GetProduct
func (mmGetProduct *mProductServiceMockGetProduct) Inspect(f func(ctx context.Context, skuId int64)) *mProductServiceMockGetProduct {
	if mmGetProduct.mock.inspectFuncGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("Inspect function is already set for ProductServiceMock.GetProduct")
	}

	mmGetProduct.mock.inspectFuncGetProduct = f

	return mmGetProduct
}

// Return sets up results that will be returned by ProductService.GetProduct
func (mmGetProduct *mProductServiceMockGetProduct) Return(p1 model.ProductModel, err error) *ProductServiceMock {
	if mmGetProduct.mock.funcGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("ProductServiceMock.GetProduct mock is already set by Set")
	}

	if mmGetProduct.defaultExpectation == nil {
		mmGetProduct.defaultExpectation = &ProductServiceMockGetProductExpectation{mock: mmGetProduct.mock}
	}
	mmGetProduct.defaultExpectation.results = &ProductServiceMockGetProductResults{p1, err}
	mmGetProduct.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetProduct.mock
}

// Set uses given function f to mock the ProductService.GetProduct method
func (mmGetProduct *mProductServiceMockGetProduct) Set(f func(ctx context.Context, skuId int64) (p1 model.ProductModel, err error)) *ProductServiceMock {
	if mmGetProduct.defaultExpectation != nil {
		mmGetProduct.mock.t.Fatalf("Default expectation is already set for the ProductService.GetProduct method")
	}

	if len(mmGetProduct.expectations) > 0 {
		mmGetProduct.mock.t.Fatalf("Some expectations are already set for the ProductService.GetProduct method")
	}

	mmGetProduct.mock.funcGetProduct = f
	mmGetProduct.mock.funcGetProductOrigin = minimock.CallerInfo(1)
	return mmGetProduct.mock
}

// When sets expectation for the ProductService.GetProduct which will trigger the result defined by the following
// Then helper
func (mmGetProduct *mProductServiceMockGetProduct) When(ctx context.Context, skuId int64) *ProductServiceMockGetProductExpectation {
	if mmGetProduct.mock.funcGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("ProductServiceMock.GetProduct mock is already set by Set")
	}

	expectation := &ProductServiceMockGetProductExpectation{
		mock:               mmGetProduct.mock,
		params:             &ProductServiceMockGetProductParams{ctx, skuId},
		expectationOrigins: ProductServiceMockGetProductExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetProduct.expectations = append(mmGetProduct.expectations, expectation)
	return expectation
}

// Then sets up ProductService.GetProduct return parameters for the expectation previously defined by the When method
func (e *ProductServiceMockGetProductExpectation) Then(p1 model.ProductModel, err error) *ProductServiceMock {
	e.results = &ProductServiceMockGetProductResults{p1, err}
	return e.mock
}

// Times sets number of times ProductService.GetProduct should be invoked
func (mmGetProduct *mProductServiceMockGetProduct) Times(n uint64) *mProductServiceMockGetProduct {
	if n == 0 {
		mmGetProduct.mock.t.Fatalf("Times of ProductServiceMock.GetProduct mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetProduct.expectedInvocations, n)
	mmGetProduct.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetProduct
}

func (mmGetProduct *mProductServiceMockGetProduct) invocationsDone() bool {
	if len(mmGetProduct.expectations) == 0 && mmGetProduct.defaultExpectation == nil && mmGetProduct.mock.funcGetProduct == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetProduct.mock.afterGetProductCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetProduct.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetProduct implements ProductService
func (mmGetProduct *ProductServiceMock) GetProduct(ctx context.Context, skuId int64) (p1 model.ProductModel, err error) {
	mm_atomic.AddUint64(&mmGetProduct.beforeGetProductCounter, 1)
	defer mm_atomic.AddUint64(&mmGetProduct.afterGetProductCounter, 1)

	mmGetProduct.t.Helper()

	if mmGetProduct.inspectFuncGetProduct != nil {
		mmGetProduct.inspectFuncGetProduct(ctx, skuId)
	}

	mm_params := ProductServiceMockGetProductParams{ctx, skuId}

	// Record call args
	mmGetProduct.GetProductMock.mutex.Lock()
	mmGetProduct.GetProductMock.callArgs = append(mmGetProduct.GetProductMock.callArgs, &mm_params)
	mmGetProduct.GetProductMock.mutex.Unlock()

	for _, e := range mmGetProduct.GetProductMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmGetProduct.GetProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetProduct.GetProductMock.defaultExpectation.Counter, 1)
		mm_want := mmGetProduct.GetProductMock.defaultExpectation.params
		mm_want_ptrs := mmGetProduct.GetProductMock.defaultExpectation.paramPtrs

		mm_got := ProductServiceMockGetProductParams{ctx, skuId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetProduct.t.Errorf("ProductServiceMock.GetProduct got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetProduct.GetProductMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.skuId != nil && !minimock.Equal(*mm_want_ptrs.skuId, mm_got.skuId) {
				mmGetProduct.t.Errorf("ProductServiceMock.GetProduct got unexpected parameter skuId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetProduct.GetProductMock.defaultExpectation.expectationOrigins.originSkuId, *mm_want_ptrs.skuId, mm_got.skuId, minimock.Diff(*mm_want_ptrs.skuId, mm_got.skuId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetProduct.t.Errorf("ProductServiceMock.GetProduct got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetProduct.GetProductMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetProduct.GetProductMock.defaultExpectation.results
		if mm_results == nil {
			mmGetProduct.t.Fatal("No results are set for the ProductServiceMock.GetProduct")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmGetProduct.funcGetProduct != nil {
		return mmGetProduct.funcGetProduct(ctx, skuId)
	}
	mmGetProduct.t.Fatalf("Unexpected call to ProductServiceMock.GetProduct. %v %v", ctx, skuId)
	return
}

// GetProductAfterCounter returns a count of finished ProductServiceMock.GetProduct invocations
func (mmGetProduct *ProductServiceMock) GetProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProduct.afterGetProductCounter)
}

// GetProductBeforeCounter returns a count of ProductServiceMock.GetProduct invocations
func (mmGetProduct *ProductServiceMock) GetProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProduct.beforeGetProductCounter)
}

// Calls returns a list of arguments used in each call to ProductServiceMock.GetProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetProduct *mProductServiceMockGetProduct) Calls() []*ProductServiceMockGetProductParams {
	mmGetProduct.mutex.RLock()

	argCopy := make([]*ProductServiceMockGetProductParams, len(mmGetProduct.callArgs))
	copy(argCopy, mmGetProduct.callArgs)

	mmGetProduct.mutex.RUnlock()

	return argCopy
}

// MinimockGetProductDone returns true if the count of the GetProduct invocations corresponds
// the number of defined expectations
func (m *ProductServiceMock) MinimockGetProductDone() bool {
	if m.GetProductMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetProductMock.invocationsDone()
}

// MinimockGetProductInspect logs each unmet expectation
func (m *ProductServiceMock) MinimockGetProductInspect() {
	for _, e := range m.GetProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProductServiceMock.GetProduct at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetProductCounter := mm_atomic.LoadUint64(&m.afterGetProductCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetProductMock.defaultExpectation != nil && afterGetProductCounter < 1 {
		if m.GetProductMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProductServiceMock.GetProduct at\n%s", m.GetProductMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProductServiceMock.GetProduct at\n%s with params: %#v", m.GetProductMock.defaultExpectation.expectationOrigins.origin, *m.GetProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProduct != nil && afterGetProductCounter < 1 {
		m.t.Errorf("Expected call to ProductServiceMock.GetProduct at\n%s", m.funcGetProductOrigin)
	}

	if !m.GetProductMock.invocationsDone() && afterGetProductCounter > 0 {
		m.t.Errorf("Expected %d calls to ProductServiceMock.GetProduct at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetProductMock.expectedInvocations), m.GetProductMock.expectedInvocationsOrigin, afterGetProductCounter)
	}
}

type mProductServiceMockGetProductsAot struct {
	optional           bool
	mock               *ProductServiceMock
	defaultExpectation *ProductServiceMockGetProductsAotExpectation
	expectations       []*ProductServiceMockGetProductsAotExpectation

	callArgs []*ProductServiceMockGetProductsAotParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProductServiceMockGetProductsAotExpectation specifies expectation struct of the ProductService.GetProductsAot
type ProductServiceMockGetProductsAotExpectation struct {
	mock               *ProductServiceMock
	params             *ProductServiceMockGetProductsAotParams
	paramPtrs          *ProductServiceMockGetProductsAotParamPtrs
	expectationOrigins ProductServiceMockGetProductsAotExpectationOrigins
	results            *ProductServiceMockGetProductsAotResults
	returnOrigin       string
	Counter            uint64
}

// ProductServiceMockGetProductsAotParams contains parameters of the ProductService.GetProductsAot
type ProductServiceMockGetProductsAotParams struct {
	ctx        context.Context
	count      int64
	startSkuId int64
}

// ProductServiceMockGetProductsAotParamPtrs contains pointers to parameters of the ProductService.GetProductsAot
type ProductServiceMockGetProductsAotParamPtrs struct {
	ctx        *context.Context
	count      *int64
	startSkuId *int64
}

// ProductServiceMockGetProductsAotResults contains results of the ProductService.GetProductsAot
type ProductServiceMockGetProductsAotResults struct {
	pa1 []model.ProductModel
	err error
}

// ProductServiceMockGetProductsAotOrigins contains origins of expectations of the ProductService.GetProductsAot
type ProductServiceMockGetProductsAotExpectationOrigins struct {
	origin           string
	originCtx        string
	originCount      string
	originStartSkuId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetProductsAot *mProductServiceMockGetProductsAot) Optional() *mProductServiceMockGetProductsAot {
	mmGetProductsAot.optional = true
	return mmGetProductsAot
}

// Expect sets up expected params for ProductService.GetProductsAot
func (mmGetProductsAot *mProductServiceMockGetProductsAot) Expect(ctx context.Context, count int64, startSkuId int64) *mProductServiceMockGetProductsAot {
	if mmGetProductsAot.mock.funcGetProductsAot != nil {
		mmGetProductsAot.mock.t.Fatalf("ProductServiceMock.GetProductsAot mock is already set by Set")
	}

	if mmGetProductsAot.defaultExpectation == nil {
		mmGetProductsAot.defaultExpectation = &ProductServiceMockGetProductsAotExpectation{}
	}

	if mmGetProductsAot.defaultExpectation.paramPtrs != nil {
		mmGetProductsAot.mock.t.Fatalf("ProductServiceMock.GetProductsAot mock is already set by ExpectParams functions")
	}

	mmGetProductsAot.defaultExpectation.params = &ProductServiceMockGetProductsAotParams{ctx, count, startSkuId}
	mmGetProductsAot.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetProductsAot.expectations {
		if minimock.Equal(e.params, mmGetProductsAot.defaultExpectation.params) {
			mmGetProductsAot.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetProductsAot.defaultExpectation.params)
		}
	}

	return mmGetProductsAot
}

// ExpectCtxParam1 sets up expected param ctx for ProductService.GetProductsAot
func (mmGetProductsAot *mProductServiceMockGetProductsAot) ExpectCtxParam1(ctx context.Context) *mProductServiceMockGetProductsAot {
	if mmGetProductsAot.mock.funcGetProductsAot != nil {
		mmGetProductsAot.mock.t.Fatalf("ProductServiceMock.GetProductsAot mock is already set by Set")
	}

	if mmGetProductsAot.defaultExpectation == nil {
		mmGetProductsAot.defaultExpectation = &ProductServiceMockGetProductsAotExpectation{}
	}

	if mmGetProductsAot.defaultExpectation.params != nil {
		mmGetProductsAot.mock.t.Fatalf("ProductServiceMock.GetProductsAot mock is already set by Expect")
	}

	if mmGetProductsAot.defaultExpectation.paramPtrs == nil {
		mmGetProductsAot.defaultExpectation.paramPtrs = &ProductServiceMockGetProductsAotParamPtrs{}
	}
	mmGetProductsAot.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetProductsAot.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetProductsAot
}

// ExpectCountParam2 sets up expected param count for ProductService.GetProductsAot
func (mmGetProductsAot *mProductServiceMockGetProductsAot) ExpectCountParam2(count int64) *mProductServiceMockGetProductsAot {
	if mmGetProductsAot.mock.funcGetProductsAot != nil {
		mmGetProductsAot.mock.t.Fatalf("ProductServiceMock.GetProductsAot mock is already set by Set")
	}

	if mmGetProductsAot.defaultExpectation == nil {
		mmGetProductsAot.defaultExpectation = &ProductServiceMockGetProductsAotExpectation{}
	}

	if mmGetProductsAot.defaultExpectation.params != nil {
		mmGetProductsAot.mock.t.Fatalf("ProductServiceMock.GetProductsAot mock is already set by Expect")
	}

	if mmGetProductsAot.defaultExpectation.paramPtrs == nil {
		mmGetProductsAot.defaultExpectation.paramPtrs = &ProductServiceMockGetProductsAotParamPtrs{}
	}
	mmGetProductsAot.defaultExpectation.paramPtrs.count = &count
	mmGetProductsAot.defaultExpectation.expectationOrigins.originCount = minimock.CallerInfo(1)

	return mmGetProductsAot
}

// ExpectStartSkuIdParam3 sets up expected param startSkuId for ProductService.GetProductsAot
func (mmGetProductsAot *mProductServiceMockGetProductsAot) ExpectStartSkuIdParam3(startSkuId int64) *mProductServiceMockGetProductsAot {
	if mmGetProductsAot.mock.funcGetProductsAot != nil {
		mmGetProductsAot.mock.t.Fatalf("ProductServiceMock.GetProductsAot mock is already set by Set")
	}

	if mmGetProductsAot.defaultExpectation == nil {
		mmGetProductsAot.defaultExpectation = &ProductServiceMockGetProductsAotExpectation{}
	}

	if mmGetProductsAot.defaultExpectation.params != nil {
		mmGetProductsAot.mock.t.Fatalf("ProductServiceMock.GetProductsAot mock is already set by Expect")
	}

	if mmGetProductsAot.defaultExpectation.paramPtrs == nil {
		mmGetProductsAot.defaultExpectation.paramPtrs = &ProductServiceMockGetProductsAotParamPtrs{}
	}
	mmGetProductsAot.defaultExpectation.paramPtrs.startSkuId = &startSkuId
	mmGetProductsAot.defaultExpectation.expectationOrigins.originStartSkuId = minimock.CallerInfo(1)

	return mmGetProductsAot
}

// Inspect accepts an inspector function that has same arguments as the ProductService.GetProductsAot
func (mmGetProductsAot *mProductServiceMockGetProductsAot) Inspect(f func(ctx context.Context, count int64, startSkuId int64)) *mProductServiceMockGetProductsAot {
	if mmGetProductsAot.mock.inspectFuncGetProductsAot != nil {
		mmGetProductsAot.mock.t.Fatalf("Inspect function is already set for ProductServiceMock.GetProductsAot")
	}

	mmGetProductsAot.mock.inspectFuncGetProductsAot = f

	return mmGetProductsAot
}

// Return sets up results that will be returned by ProductService.GetProductsAot
func (mmGetProductsAot *mProductServiceMockGetProductsAot) Return(pa1 []model.ProductModel, err error) *ProductServiceMock {
	if mmGetProductsAot.mock.funcGetProductsAot != nil {
		mmGetProductsAot.mock.t.Fatalf("ProductServiceMock.GetProductsAot mock is already set by Set")
	}

	if mmGetProductsAot.defaultExpectation == nil {
		mmGetProductsAot.defaultExpectation = &ProductServiceMockGetProductsAotExpectation{mock: mmGetProductsAot.mock}
	}
	mmGetProductsAot.defaultExpectation.results = &ProductServiceMockGetProductsAotResults{pa1, err}
	mmGetProductsAot.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetProductsAot.mock
}

// Set uses given function f to mock the ProductService.GetProductsAot method
func (mmGetProductsAot *mProductServiceMockGetProductsAot) Set(f func(ctx context.Context, count int64, startSkuId int64) (pa1 []model.ProductModel, err error)) *ProductServiceMock {
	if mmGetProductsAot.defaultExpectation != nil {
		mmGetProductsAot.mock.t.Fatalf("Default expectation is already set for the ProductService.GetProductsAot method")
	}

	if len(mmGetProductsAot.expectations) > 0 {
		mmGetProductsAot.mock.t.Fatalf("Some expectations are already set for the ProductService.GetProductsAot method")
	}

	mmGetProductsAot.mock.funcGetProductsAot = f
	mmGetProductsAot.mock.funcGetProductsAotOrigin = minimock.CallerInfo(1)
	return mmGetProductsAot.mock
}

// When sets expectation for the ProductService.GetProductsAot which will trigger the result defined by the following
// Then helper
func (mmGetProductsAot *mProductServiceMockGetProductsAot) When(ctx context.Context, count int64, startSkuId int64) *ProductServiceMockGetProductsAotExpectation {
	if mmGetProductsAot.mock.funcGetProductsAot != nil {
		mmGetProductsAot.mock.t.Fatalf("ProductServiceMock.GetProductsAot mock is already set by Set")
	}

	expectation := &ProductServiceMockGetProductsAotExpectation{
		mock:               mmGetProductsAot.mock,
		params:             &ProductServiceMockGetProductsAotParams{ctx, count, startSkuId},
		expectationOrigins: ProductServiceMockGetProductsAotExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetProductsAot.expectations = append(mmGetProductsAot.expectations, expectation)
	return expectation
}

// Then sets up ProductService.GetProductsAot return parameters for the expectation previously defined by the When method
func (e *ProductServiceMockGetProductsAotExpectation) Then(pa1 []model.ProductModel, err error) *ProductServiceMock {
	e.results = &ProductServiceMockGetProductsAotResults{pa1, err}
	return e.mock
}

// Times sets number of times ProductService.GetProductsAot should be invoked
func (mmGetProductsAot *mProductServiceMockGetProductsAot) Times(n uint64) *mProductServiceMockGetProductsAot {
	if n == 0 {
		mmGetProductsAot.mock.t.Fatalf("Times of ProductServiceMock.GetProductsAot mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetProductsAot.expectedInvocations, n)
	mmGetProductsAot.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetProductsAot
}

func (mmGetProductsAot *mProductServiceMockGetProductsAot) invocationsDone() bool {
	if len(mmGetProductsAot.expectations) == 0 && mmGetProductsAot.defaultExpectation == nil && mmGetProductsAot.mock.funcGetProductsAot == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetProductsAot.mock.afterGetProductsAotCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetProductsAot.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetProductsAot implements ProductService
func (mmGetProductsAot *ProductServiceMock) GetProductsAot(ctx context.Context, count int64, startSkuId int64) (pa1 []model.ProductModel, err error) {
	mm_atomic.AddUint64(&mmGetProductsAot.beforeGetProductsAotCounter, 1)
	defer mm_atomic.AddUint64(&mmGetProductsAot.afterGetProductsAotCounter, 1)

	mmGetProductsAot.t.Helper()

	if mmGetProductsAot.inspectFuncGetProductsAot != nil {
		mmGetProductsAot.inspectFuncGetProductsAot(ctx, count, startSkuId)
	}

	mm_params := ProductServiceMockGetProductsAotParams{ctx, count, startSkuId}

	// Record call args
	mmGetProductsAot.GetProductsAotMock.mutex.Lock()
	mmGetProductsAot.GetProductsAotMock.callArgs = append(mmGetProductsAot.GetProductsAotMock.callArgs, &mm_params)
	mmGetProductsAot.GetProductsAotMock.mutex.Unlock()

	for _, e := range mmGetProductsAot.GetProductsAotMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmGetProductsAot.GetProductsAotMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetProductsAot.GetProductsAotMock.defaultExpectation.Counter, 1)
		mm_want := mmGetProductsAot.GetProductsAotMock.defaultExpectation.params
		mm_want_ptrs := mmGetProductsAot.GetProductsAotMock.defaultExpectation.paramPtrs

		mm_got := ProductServiceMockGetProductsAotParams{ctx, count, startSkuId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetProductsAot.t.Errorf("ProductServiceMock.GetProductsAot got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetProductsAot.GetProductsAotMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmGetProductsAot.t.Errorf("ProductServiceMock.GetProductsAot got unexpected parameter count, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetProductsAot.GetProductsAotMock.defaultExpectation.expectationOrigins.originCount, *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

			if mm_want_ptrs.startSkuId != nil && !minimock.Equal(*mm_want_ptrs.startSkuId, mm_got.startSkuId) {
				mmGetProductsAot.t.Errorf("ProductServiceMock.GetProductsAot got unexpected parameter startSkuId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetProductsAot.GetProductsAotMock.defaultExpectation.expectationOrigins.originStartSkuId, *mm_want_ptrs.startSkuId, mm_got.startSkuId, minimock.Diff(*mm_want_ptrs.startSkuId, mm_got.startSkuId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetProductsAot.t.Errorf("ProductServiceMock.GetProductsAot got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetProductsAot.GetProductsAotMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetProductsAot.GetProductsAotMock.defaultExpectation.results
		if mm_results == nil {
			mmGetProductsAot.t.Fatal("No results are set for the ProductServiceMock.GetProductsAot")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmGetProductsAot.funcGetProductsAot != nil {
		return mmGetProductsAot.funcGetProductsAot(ctx, count, startSkuId)
	}
	mmGetProductsAot.t.Fatalf("Unexpected call to ProductServiceMock.GetProductsAot. %v %v %v", ctx, count, startSkuId)
	return
}

// GetProductsAotAfterCounter returns a count of finished ProductServiceMock.GetProductsAot invocations
func (mmGetProductsAot *ProductServiceMock) GetProductsAotAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProductsAot.afterGetProductsAotCounter)
}

// GetProductsAotBeforeCounter returns a count of ProductServiceMock.GetProductsAot invocations
func (mmGetProductsAot *ProductServiceMock) GetProductsAotBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProductsAot.beforeGetProductsAotCounter)
}

// Calls returns a list of arguments used in each call to ProductServiceMock.GetProductsAot.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetProductsAot *mProductServiceMockGetProductsAot) Calls() []*ProductServiceMockGetProductsAotParams {
	mmGetProductsAot.mutex.RLock()

	argCopy := make([]*ProductServiceMockGetProductsAotParams, len(mmGetProductsAot.callArgs))
	copy(argCopy, mmGetProductsAot.callArgs)

	mmGetProductsAot.mutex.RUnlock()

	return argCopy
}

// MinimockGetProductsAotDone returns true if the count of the GetProductsAot invocations corresponds
// the number of defined expectations
func (m *ProductServiceMock) MinimockGetProductsAotDone() bool {
	if m.GetProductsAotMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetProductsAotMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetProductsAotMock.invocationsDone()
}

// MinimockGetProductsAotInspect logs each unmet expectation
func (m *ProductServiceMock) MinimockGetProductsAotInspect() {
	for _, e := range m.GetProductsAotMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProductServiceMock.GetProductsAot at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetProductsAotCounter := mm_atomic.LoadUint64(&m.afterGetProductsAotCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetProductsAotMock.defaultExpectation != nil && afterGetProductsAotCounter < 1 {
		if m.GetProductsAotMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProductServiceMock.GetProductsAot at\n%s", m.GetProductsAotMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProductServiceMock.GetProductsAot at\n%s with params: %#v", m.GetProductsAotMock.defaultExpectation.expectationOrigins.origin, *m.GetProductsAotMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProductsAot != nil && afterGetProductsAotCounter < 1 {
		m.t.Errorf("Expected call to ProductServiceMock.GetProductsAot at\n%s", m.funcGetProductsAotOrigin)
	}

	if !m.GetProductsAotMock.invocationsDone() && afterGetProductsAotCounter > 0 {
		m.t.Errorf("Expected %d calls to ProductServiceMock.GetProductsAot at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetProductsAotMock.expectedInvocations), m.GetProductsAotMock.expectedInvocationsOrigin, afterGetProductsAotCounter)
	}
}

type mProductServiceMockIsProductExists struct {
	optional           bool
	mock               *ProductServiceMock
	defaultExpectation *ProductServiceMockIsProductExistsExpectation
	expectations       []*ProductServiceMockIsProductExistsExpectation

	callArgs []*ProductServiceMockIsProductExistsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProductServiceMockIsProductExistsExpectation specifies expectation struct of the ProductService.IsProductExists
type ProductServiceMockIsProductExistsExpectation struct {
	mock               *ProductServiceMock
	params             *ProductServiceMockIsProductExistsParams
	paramPtrs          *ProductServiceMockIsProductExistsParamPtrs
	expectationOrigins ProductServiceMockIsProductExistsExpectationOrigins
	results            *ProductServiceMockIsProductExistsResults
	returnOrigin       string
	Counter            uint64
}

// ProductServiceMockIsProductExistsParams contains parameters of the ProductService.IsProductExists
type ProductServiceMockIsProductExistsParams struct {
	ctx   context.Context
	skuId int64
}

// ProductServiceMockIsProductExistsParamPtrs contains pointers to parameters of the ProductService.IsProductExists
type ProductServiceMockIsProductExistsParamPtrs struct {
	ctx   *context.Context
	skuId *int64
}

// ProductServiceMockIsProductExistsResults contains results of the ProductService.IsProductExists
type ProductServiceMockIsProductExistsResults struct {
	b1  bool
	err error
}

// ProductServiceMockIsProductExistsOrigins contains origins of expectations of the ProductService.IsProductExists
type ProductServiceMockIsProductExistsExpectationOrigins struct {
	origin      string
	originCtx   string
	originSkuId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsProductExists *mProductServiceMockIsProductExists) Optional() *mProductServiceMockIsProductExists {
	mmIsProductExists.optional = true
	return mmIsProductExists
}

// Expect sets up expected params for ProductService.IsProductExists
func (mmIsProductExists *mProductServiceMockIsProductExists) Expect(ctx context.Context, skuId int64) *mProductServiceMockIsProductExists {
	if mmIsProductExists.mock.funcIsProductExists != nil {
		mmIsProductExists.mock.t.Fatalf("ProductServiceMock.IsProductExists mock is already set by Set")
	}

	if mmIsProductExists.defaultExpectation == nil {
		mmIsProductExists.defaultExpectation = &ProductServiceMockIsProductExistsExpectation{}
	}

	if mmIsProductExists.defaultExpectation.paramPtrs != nil {
		mmIsProductExists.mock.t.Fatalf("ProductServiceMock.IsProductExists mock is already set by ExpectParams functions")
	}

	mmIsProductExists.defaultExpectation.params = &ProductServiceMockIsProductExistsParams{ctx, skuId}
	mmIsProductExists.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsProductExists.expectations {
		if minimock.Equal(e.params, mmIsProductExists.defaultExpectation.params) {
			mmIsProductExists.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsProductExists.defaultExpectation.params)
		}
	}

	return mmIsProductExists
}

// ExpectCtxParam1 sets up expected param ctx for ProductService.IsProductExists
func (mmIsProductExists *mProductServiceMockIsProductExists) ExpectCtxParam1(ctx context.Context) *mProductServiceMockIsProductExists {
	if mmIsProductExists.mock.funcIsProductExists != nil {
		mmIsProductExists.mock.t.Fatalf("ProductServiceMock.IsProductExists mock is already set by Set")
	}

	if mmIsProductExists.defaultExpectation == nil {
		mmIsProductExists.defaultExpectation = &ProductServiceMockIsProductExistsExpectation{}
	}

	if mmIsProductExists.defaultExpectation.params != nil {
		mmIsProductExists.mock.t.Fatalf("ProductServiceMock.IsProductExists mock is already set by Expect")
	}

	if mmIsProductExists.defaultExpectation.paramPtrs == nil {
		mmIsProductExists.defaultExpectation.paramPtrs = &ProductServiceMockIsProductExistsParamPtrs{}
	}
	mmIsProductExists.defaultExpectation.paramPtrs.ctx = &ctx
	mmIsProductExists.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIsProductExists
}

// ExpectSkuIdParam2 sets up expected param skuId for ProductService.IsProductExists
func (mmIsProductExists *mProductServiceMockIsProductExists) ExpectSkuIdParam2(skuId int64) *mProductServiceMockIsProductExists {
	if mmIsProductExists.mock.funcIsProductExists != nil {
		mmIsProductExists.mock.t.Fatalf("ProductServiceMock.IsProductExists mock is already set by Set")
	}

	if mmIsProductExists.defaultExpectation == nil {
		mmIsProductExists.defaultExpectation = &ProductServiceMockIsProductExistsExpectation{}
	}

	if mmIsProductExists.defaultExpectation.params != nil {
		mmIsProductExists.mock.t.Fatalf("ProductServiceMock.IsProductExists mock is already set by Expect")
	}

	if mmIsProductExists.defaultExpectation.paramPtrs == nil {
		mmIsProductExists.defaultExpectation.paramPtrs = &ProductServiceMockIsProductExistsParamPtrs{}
	}
	mmIsProductExists.defaultExpectation.paramPtrs.skuId = &skuId
	mmIsProductExists.defaultExpectation.expectationOrigins.originSkuId = minimock.CallerInfo(1)

	return mmIsProductExists
}

// Inspect accepts an inspector function that has same arguments as the ProductService.IsProductExists
func (mmIsProductExists *mProductServiceMockIsProductExists) Inspect(f func(ctx context.Context, skuId int64)) *mProductServiceMockIsProductExists {
	if mmIsProductExists.mock.inspectFuncIsProductExists != nil {
		mmIsProductExists.mock.t.Fatalf("Inspect function is already set for ProductServiceMock.IsProductExists")
	}

	mmIsProductExists.mock.inspectFuncIsProductExists = f

	return mmIsProductExists
}

// Return sets up results that will be returned by ProductService.IsProductExists
func (mmIsProductExists *mProductServiceMockIsProductExists) Return(b1 bool, err error) *ProductServiceMock {
	if mmIsProductExists.mock.funcIsProductExists != nil {
		mmIsProductExists.mock.t.Fatalf("ProductServiceMock.IsProductExists mock is already set by Set")
	}

	if mmIsProductExists.defaultExpectation == nil {
		mmIsProductExists.defaultExpectation = &ProductServiceMockIsProductExistsExpectation{mock: mmIsProductExists.mock}
	}
	mmIsProductExists.defaultExpectation.results = &ProductServiceMockIsProductExistsResults{b1, err}
	mmIsProductExists.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsProductExists.mock
}

// Set uses given function f to mock the ProductService.IsProductExists method
func (mmIsProductExists *mProductServiceMockIsProductExists) Set(f func(ctx context.Context, skuId int64) (b1 bool, err error)) *ProductServiceMock {
	if mmIsProductExists.defaultExpectation != nil {
		mmIsProductExists.mock.t.Fatalf("Default expectation is already set for the ProductService.IsProductExists method")
	}

	if len(mmIsProductExists.expectations) > 0 {
		mmIsProductExists.mock.t.Fatalf("Some expectations are already set for the ProductService.IsProductExists method")
	}

	mmIsProductExists.mock.funcIsProductExists = f
	mmIsProductExists.mock.funcIsProductExistsOrigin = minimock.CallerInfo(1)
	return mmIsProductExists.mock
}

// When sets expectation for the ProductService.IsProductExists which will trigger the result defined by the following
// Then helper
func (mmIsProductExists *mProductServiceMockIsProductExists) When(ctx context.Context, skuId int64) *ProductServiceMockIsProductExistsExpectation {
	if mmIsProductExists.mock.funcIsProductExists != nil {
		mmIsProductExists.mock.t.Fatalf("ProductServiceMock.IsProductExists mock is already set by Set")
	}

	expectation := &ProductServiceMockIsProductExistsExpectation{
		mock:               mmIsProductExists.mock,
		params:             &ProductServiceMockIsProductExistsParams{ctx, skuId},
		expectationOrigins: ProductServiceMockIsProductExistsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsProductExists.expectations = append(mmIsProductExists.expectations, expectation)
	return expectation
}

// Then sets up ProductService.IsProductExists return parameters for the expectation previously defined by the When method
func (e *ProductServiceMockIsProductExistsExpectation) Then(b1 bool, err error) *ProductServiceMock {
	e.results = &ProductServiceMockIsProductExistsResults{b1, err}
	return e.mock
}

// Times sets number of times ProductService.IsProductExists should be invoked
func (mmIsProductExists *mProductServiceMockIsProductExists) Times(n uint64) *mProductServiceMockIsProductExists {
	if n == 0 {
		mmIsProductExists.mock.t.Fatalf("Times of ProductServiceMock.IsProductExists mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsProductExists.expectedInvocations, n)
	mmIsProductExists.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsProductExists
}

func (mmIsProductExists *mProductServiceMockIsProductExists) invocationsDone() bool {
	if len(mmIsProductExists.expectations) == 0 && mmIsProductExists.defaultExpectation == nil && mmIsProductExists.mock.funcIsProductExists == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsProductExists.mock.afterIsProductExistsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsProductExists.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsProductExists implements ProductService
func (mmIsProductExists *ProductServiceMock) IsProductExists(ctx context.Context, skuId int64) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsProductExists.beforeIsProductExistsCounter, 1)
	defer mm_atomic.AddUint64(&mmIsProductExists.afterIsProductExistsCounter, 1)

	mmIsProductExists.t.Helper()

	if mmIsProductExists.inspectFuncIsProductExists != nil {
		mmIsProductExists.inspectFuncIsProductExists(ctx, skuId)
	}

	mm_params := ProductServiceMockIsProductExistsParams{ctx, skuId}

	// Record call args
	mmIsProductExists.IsProductExistsMock.mutex.Lock()
	mmIsProductExists.IsProductExistsMock.callArgs = append(mmIsProductExists.IsProductExistsMock.callArgs, &mm_params)
	mmIsProductExists.IsProductExistsMock.mutex.Unlock()

	for _, e := range mmIsProductExists.IsProductExistsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsProductExists.IsProductExistsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsProductExists.IsProductExistsMock.defaultExpectation.Counter, 1)
		mm_want := mmIsProductExists.IsProductExistsMock.defaultExpectation.params
		mm_want_ptrs := mmIsProductExists.IsProductExistsMock.defaultExpectation.paramPtrs

		mm_got := ProductServiceMockIsProductExistsParams{ctx, skuId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIsProductExists.t.Errorf("ProductServiceMock.IsProductExists got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsProductExists.IsProductExistsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.skuId != nil && !minimock.Equal(*mm_want_ptrs.skuId, mm_got.skuId) {
				mmIsProductExists.t.Errorf("ProductServiceMock.IsProductExists got unexpected parameter skuId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsProductExists.IsProductExistsMock.defaultExpectation.expectationOrigins.originSkuId, *mm_want_ptrs.skuId, mm_got.skuId, minimock.Diff(*mm_want_ptrs.skuId, mm_got.skuId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsProductExists.t.Errorf("ProductServiceMock.IsProductExists got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsProductExists.IsProductExistsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsProductExists.IsProductExistsMock.defaultExpectation.results
		if mm_results == nil {
			mmIsProductExists.t.Fatal("No results are set for the ProductServiceMock.IsProductExists")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsProductExists.funcIsProductExists != nil {
		return mmIsProductExists.funcIsProductExists(ctx, skuId)
	}
	mmIsProductExists.t.Fatalf("Unexpected call to ProductServiceMock.IsProductExists. %v %v", ctx, skuId)
	return
}

// IsProductExistsAfterCounter returns a count of finished ProductServiceMock.IsProductExists invocations
func (mmIsProductExists *ProductServiceMock) IsProductExistsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsProductExists.afterIsProductExistsCounter)
}

// IsProductExistsBeforeCounter returns a count of ProductServiceMock.IsProductExists invocations
func (mmIsProductExists *ProductServiceMock) IsProductExistsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsProductExists.beforeIsProductExistsCounter)
}

// Calls returns a list of arguments used in each call to ProductServiceMock.IsProductExists.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsProductExists *mProductServiceMockIsProductExists) Calls() []*ProductServiceMockIsProductExistsParams {
	mmIsProductExists.mutex.RLock()

	argCopy := make([]*ProductServiceMockIsProductExistsParams, len(mmIsProductExists.callArgs))
	copy(argCopy, mmIsProductExists.callArgs)

	mmIsProductExists.mutex.RUnlock()

	return argCopy
}

// MinimockIsProductExistsDone returns true if the count of the IsProductExists invocations corresponds
// the number of defined expectations
func (m *ProductServiceMock) MinimockIsProductExistsDone() bool {
	if m.IsProductExistsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsProductExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsProductExistsMock.invocationsDone()
}

// MinimockIsProductExistsInspect logs each unmet expectation
func (m *ProductServiceMock) MinimockIsProductExistsInspect() {
	for _, e := range m.IsProductExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProductServiceMock.IsProductExists at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsProductExistsCounter := mm_atomic.LoadUint64(&m.afterIsProductExistsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsProductExistsMock.defaultExpectation != nil && afterIsProductExistsCounter < 1 {
		if m.IsProductExistsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProductServiceMock.IsProductExists at\n%s", m.IsProductExistsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProductServiceMock.IsProductExists at\n%s with params: %#v", m.IsProductExistsMock.defaultExpectation.expectationOrigins.origin, *m.IsProductExistsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsProductExists != nil && afterIsProductExistsCounter < 1 {
		m.t.Errorf("Expected call to ProductServiceMock.IsProductExists at\n%s", m.funcIsProductExistsOrigin)
	}

	if !m.IsProductExistsMock.invocationsDone() && afterIsProductExistsCounter > 0 {
		m.t.Errorf("Expected %d calls to ProductServiceMock.IsProductExists at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsProductExistsMock.expectedInvocations), m.IsProductExistsMock.expectedInvocationsOrigin, afterIsProductExistsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ProductServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetProductInspect()

			m.MinimockGetProductsAotInspect()

			m.MinimockIsProductExistsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ProductServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ProductServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetProductDone() &&
		m.MinimockGetProductsAotDone() &&
		m.MinimockIsProductExistsDone()
}
