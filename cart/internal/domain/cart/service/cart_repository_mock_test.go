// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package service_test

//go:generate minimock -i route256/cart/internal/domain/cart/service.CartRepository -o cart_repository_mock_test.go -n CartRepositoryMock -p service_test

import (
	"context"
	"route256/cart/internal/domain/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CartRepositoryMock implements CartRepository
type CartRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateItem          func(ctx context.Context, item *model.CartItemModel) (b1 bool, err error)
	funcCreateItemOrigin    string
	inspectFuncCreateItem   func(ctx context.Context, item *model.CartItemModel)
	afterCreateItemCounter  uint64
	beforeCreateItemCounter uint64
	CreateItemMock          mCartRepositoryMockCreateItem

	funcDeleteAll          func(ctx context.Context, userId int64)
	funcDeleteAllOrigin    string
	inspectFuncDeleteAll   func(ctx context.Context, userId int64)
	afterDeleteAllCounter  uint64
	beforeDeleteAllCounter uint64
	DeleteAllMock          mCartRepositoryMockDeleteAll

	funcDeleteBySku          func(ctx context.Context, userId int64, skuId int64)
	funcDeleteBySkuOrigin    string
	inspectFuncDeleteBySku   func(ctx context.Context, userId int64, skuId int64)
	afterDeleteBySkuCounter  uint64
	beforeDeleteBySkuCounter uint64
	DeleteBySkuMock          mCartRepositoryMockDeleteBySku

	funcGetAllOrderBySku          func(ctx context.Context, userId int64) (ca1 []model.CartItemModel)
	funcGetAllOrderBySkuOrigin    string
	inspectFuncGetAllOrderBySku   func(ctx context.Context, userId int64)
	afterGetAllOrderBySkuCounter  uint64
	beforeGetAllOrderBySkuCounter uint64
	GetAllOrderBySkuMock          mCartRepositoryMockGetAllOrderBySku
}

// NewCartRepositoryMock returns a mock for CartRepository
func NewCartRepositoryMock(t minimock.Tester) *CartRepositoryMock {
	m := &CartRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateItemMock = mCartRepositoryMockCreateItem{mock: m}
	m.CreateItemMock.callArgs = []*CartRepositoryMockCreateItemParams{}

	m.DeleteAllMock = mCartRepositoryMockDeleteAll{mock: m}
	m.DeleteAllMock.callArgs = []*CartRepositoryMockDeleteAllParams{}

	m.DeleteBySkuMock = mCartRepositoryMockDeleteBySku{mock: m}
	m.DeleteBySkuMock.callArgs = []*CartRepositoryMockDeleteBySkuParams{}

	m.GetAllOrderBySkuMock = mCartRepositoryMockGetAllOrderBySku{mock: m}
	m.GetAllOrderBySkuMock.callArgs = []*CartRepositoryMockGetAllOrderBySkuParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCartRepositoryMockCreateItem struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockCreateItemExpectation
	expectations       []*CartRepositoryMockCreateItemExpectation

	callArgs []*CartRepositoryMockCreateItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockCreateItemExpectation specifies expectation struct of the CartRepository.CreateItem
type CartRepositoryMockCreateItemExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockCreateItemParams
	paramPtrs          *CartRepositoryMockCreateItemParamPtrs
	expectationOrigins CartRepositoryMockCreateItemExpectationOrigins
	results            *CartRepositoryMockCreateItemResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockCreateItemParams contains parameters of the CartRepository.CreateItem
type CartRepositoryMockCreateItemParams struct {
	ctx  context.Context
	item *model.CartItemModel
}

// CartRepositoryMockCreateItemParamPtrs contains pointers to parameters of the CartRepository.CreateItem
type CartRepositoryMockCreateItemParamPtrs struct {
	ctx  *context.Context
	item **model.CartItemModel
}

// CartRepositoryMockCreateItemResults contains results of the CartRepository.CreateItem
type CartRepositoryMockCreateItemResults struct {
	b1  bool
	err error
}

// CartRepositoryMockCreateItemOrigins contains origins of expectations of the CartRepository.CreateItem
type CartRepositoryMockCreateItemExpectationOrigins struct {
	origin     string
	originCtx  string
	originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateItem *mCartRepositoryMockCreateItem) Optional() *mCartRepositoryMockCreateItem {
	mmCreateItem.optional = true
	return mmCreateItem
}

// Expect sets up expected params for CartRepository.CreateItem
func (mmCreateItem *mCartRepositoryMockCreateItem) Expect(ctx context.Context, item *model.CartItemModel) *mCartRepositoryMockCreateItem {
	if mmCreateItem.mock.funcCreateItem != nil {
		mmCreateItem.mock.t.Fatalf("CartRepositoryMock.CreateItem mock is already set by Set")
	}

	if mmCreateItem.defaultExpectation == nil {
		mmCreateItem.defaultExpectation = &CartRepositoryMockCreateItemExpectation{}
	}

	if mmCreateItem.defaultExpectation.paramPtrs != nil {
		mmCreateItem.mock.t.Fatalf("CartRepositoryMock.CreateItem mock is already set by ExpectParams functions")
	}

	mmCreateItem.defaultExpectation.params = &CartRepositoryMockCreateItemParams{ctx, item}
	mmCreateItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateItem.expectations {
		if minimock.Equal(e.params, mmCreateItem.defaultExpectation.params) {
			mmCreateItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateItem.defaultExpectation.params)
		}
	}

	return mmCreateItem
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.CreateItem
func (mmCreateItem *mCartRepositoryMockCreateItem) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockCreateItem {
	if mmCreateItem.mock.funcCreateItem != nil {
		mmCreateItem.mock.t.Fatalf("CartRepositoryMock.CreateItem mock is already set by Set")
	}

	if mmCreateItem.defaultExpectation == nil {
		mmCreateItem.defaultExpectation = &CartRepositoryMockCreateItemExpectation{}
	}

	if mmCreateItem.defaultExpectation.params != nil {
		mmCreateItem.mock.t.Fatalf("CartRepositoryMock.CreateItem mock is already set by Expect")
	}

	if mmCreateItem.defaultExpectation.paramPtrs == nil {
		mmCreateItem.defaultExpectation.paramPtrs = &CartRepositoryMockCreateItemParamPtrs{}
	}
	mmCreateItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateItem
}

// ExpectItemParam2 sets up expected param item for CartRepository.CreateItem
func (mmCreateItem *mCartRepositoryMockCreateItem) ExpectItemParam2(item *model.CartItemModel) *mCartRepositoryMockCreateItem {
	if mmCreateItem.mock.funcCreateItem != nil {
		mmCreateItem.mock.t.Fatalf("CartRepositoryMock.CreateItem mock is already set by Set")
	}

	if mmCreateItem.defaultExpectation == nil {
		mmCreateItem.defaultExpectation = &CartRepositoryMockCreateItemExpectation{}
	}

	if mmCreateItem.defaultExpectation.params != nil {
		mmCreateItem.mock.t.Fatalf("CartRepositoryMock.CreateItem mock is already set by Expect")
	}

	if mmCreateItem.defaultExpectation.paramPtrs == nil {
		mmCreateItem.defaultExpectation.paramPtrs = &CartRepositoryMockCreateItemParamPtrs{}
	}
	mmCreateItem.defaultExpectation.paramPtrs.item = &item
	mmCreateItem.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

	return mmCreateItem
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.CreateItem
func (mmCreateItem *mCartRepositoryMockCreateItem) Inspect(f func(ctx context.Context, item *model.CartItemModel)) *mCartRepositoryMockCreateItem {
	if mmCreateItem.mock.inspectFuncCreateItem != nil {
		mmCreateItem.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.CreateItem")
	}

	mmCreateItem.mock.inspectFuncCreateItem = f

	return mmCreateItem
}

// Return sets up results that will be returned by CartRepository.CreateItem
func (mmCreateItem *mCartRepositoryMockCreateItem) Return(b1 bool, err error) *CartRepositoryMock {
	if mmCreateItem.mock.funcCreateItem != nil {
		mmCreateItem.mock.t.Fatalf("CartRepositoryMock.CreateItem mock is already set by Set")
	}

	if mmCreateItem.defaultExpectation == nil {
		mmCreateItem.defaultExpectation = &CartRepositoryMockCreateItemExpectation{mock: mmCreateItem.mock}
	}
	mmCreateItem.defaultExpectation.results = &CartRepositoryMockCreateItemResults{b1, err}
	mmCreateItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateItem.mock
}

// Set uses given function f to mock the CartRepository.CreateItem method
func (mmCreateItem *mCartRepositoryMockCreateItem) Set(f func(ctx context.Context, item *model.CartItemModel) (b1 bool, err error)) *CartRepositoryMock {
	if mmCreateItem.defaultExpectation != nil {
		mmCreateItem.mock.t.Fatalf("Default expectation is already set for the CartRepository.CreateItem method")
	}

	if len(mmCreateItem.expectations) > 0 {
		mmCreateItem.mock.t.Fatalf("Some expectations are already set for the CartRepository.CreateItem method")
	}

	mmCreateItem.mock.funcCreateItem = f
	mmCreateItem.mock.funcCreateItemOrigin = minimock.CallerInfo(1)
	return mmCreateItem.mock
}

// When sets expectation for the CartRepository.CreateItem which will trigger the result defined by the following
// Then helper
func (mmCreateItem *mCartRepositoryMockCreateItem) When(ctx context.Context, item *model.CartItemModel) *CartRepositoryMockCreateItemExpectation {
	if mmCreateItem.mock.funcCreateItem != nil {
		mmCreateItem.mock.t.Fatalf("CartRepositoryMock.CreateItem mock is already set by Set")
	}

	expectation := &CartRepositoryMockCreateItemExpectation{
		mock:               mmCreateItem.mock,
		params:             &CartRepositoryMockCreateItemParams{ctx, item},
		expectationOrigins: CartRepositoryMockCreateItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateItem.expectations = append(mmCreateItem.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.CreateItem return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockCreateItemExpectation) Then(b1 bool, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockCreateItemResults{b1, err}
	return e.mock
}

// Times sets number of times CartRepository.CreateItem should be invoked
func (mmCreateItem *mCartRepositoryMockCreateItem) Times(n uint64) *mCartRepositoryMockCreateItem {
	if n == 0 {
		mmCreateItem.mock.t.Fatalf("Times of CartRepositoryMock.CreateItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateItem.expectedInvocations, n)
	mmCreateItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateItem
}

func (mmCreateItem *mCartRepositoryMockCreateItem) invocationsDone() bool {
	if len(mmCreateItem.expectations) == 0 && mmCreateItem.defaultExpectation == nil && mmCreateItem.mock.funcCreateItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateItem.mock.afterCreateItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateItem implements CartRepository
func (mmCreateItem *CartRepositoryMock) CreateItem(ctx context.Context, item *model.CartItemModel) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCreateItem.beforeCreateItemCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateItem.afterCreateItemCounter, 1)

	mmCreateItem.t.Helper()

	if mmCreateItem.inspectFuncCreateItem != nil {
		mmCreateItem.inspectFuncCreateItem(ctx, item)
	}

	mm_params := CartRepositoryMockCreateItemParams{ctx, item}

	// Record call args
	mmCreateItem.CreateItemMock.mutex.Lock()
	mmCreateItem.CreateItemMock.callArgs = append(mmCreateItem.CreateItemMock.callArgs, &mm_params)
	mmCreateItem.CreateItemMock.mutex.Unlock()

	for _, e := range mmCreateItem.CreateItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCreateItem.CreateItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateItem.CreateItemMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateItem.CreateItemMock.defaultExpectation.params
		mm_want_ptrs := mmCreateItem.CreateItemMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockCreateItemParams{ctx, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateItem.t.Errorf("CartRepositoryMock.CreateItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateItem.CreateItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmCreateItem.t.Errorf("CartRepositoryMock.CreateItem got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateItem.CreateItemMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateItem.t.Errorf("CartRepositoryMock.CreateItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateItem.CreateItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateItem.CreateItemMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateItem.t.Fatal("No results are set for the CartRepositoryMock.CreateItem")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCreateItem.funcCreateItem != nil {
		return mmCreateItem.funcCreateItem(ctx, item)
	}
	mmCreateItem.t.Fatalf("Unexpected call to CartRepositoryMock.CreateItem. %v %v", ctx, item)
	return
}

// CreateItemAfterCounter returns a count of finished CartRepositoryMock.CreateItem invocations
func (mmCreateItem *CartRepositoryMock) CreateItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateItem.afterCreateItemCounter)
}

// CreateItemBeforeCounter returns a count of CartRepositoryMock.CreateItem invocations
func (mmCreateItem *CartRepositoryMock) CreateItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateItem.beforeCreateItemCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.CreateItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateItem *mCartRepositoryMockCreateItem) Calls() []*CartRepositoryMockCreateItemParams {
	mmCreateItem.mutex.RLock()

	argCopy := make([]*CartRepositoryMockCreateItemParams, len(mmCreateItem.callArgs))
	copy(argCopy, mmCreateItem.callArgs)

	mmCreateItem.mutex.RUnlock()

	return argCopy
}

// MinimockCreateItemDone returns true if the count of the CreateItem invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockCreateItemDone() bool {
	if m.CreateItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateItemMock.invocationsDone()
}

// MinimockCreateItemInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockCreateItemInspect() {
	for _, e := range m.CreateItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.CreateItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateItemCounter := mm_atomic.LoadUint64(&m.afterCreateItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateItemMock.defaultExpectation != nil && afterCreateItemCounter < 1 {
		if m.CreateItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.CreateItem at\n%s", m.CreateItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.CreateItem at\n%s with params: %#v", m.CreateItemMock.defaultExpectation.expectationOrigins.origin, *m.CreateItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateItem != nil && afterCreateItemCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.CreateItem at\n%s", m.funcCreateItemOrigin)
	}

	if !m.CreateItemMock.invocationsDone() && afterCreateItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.CreateItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateItemMock.expectedInvocations), m.CreateItemMock.expectedInvocationsOrigin, afterCreateItemCounter)
	}
}

type mCartRepositoryMockDeleteAll struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockDeleteAllExpectation
	expectations       []*CartRepositoryMockDeleteAllExpectation

	callArgs []*CartRepositoryMockDeleteAllParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockDeleteAllExpectation specifies expectation struct of the CartRepository.DeleteAll
type CartRepositoryMockDeleteAllExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockDeleteAllParams
	paramPtrs          *CartRepositoryMockDeleteAllParamPtrs
	expectationOrigins CartRepositoryMockDeleteAllExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// CartRepositoryMockDeleteAllParams contains parameters of the CartRepository.DeleteAll
type CartRepositoryMockDeleteAllParams struct {
	ctx    context.Context
	userId int64
}

// CartRepositoryMockDeleteAllParamPtrs contains pointers to parameters of the CartRepository.DeleteAll
type CartRepositoryMockDeleteAllParamPtrs struct {
	ctx    *context.Context
	userId *int64
}

// CartRepositoryMockDeleteAllOrigins contains origins of expectations of the CartRepository.DeleteAll
type CartRepositoryMockDeleteAllExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteAll *mCartRepositoryMockDeleteAll) Optional() *mCartRepositoryMockDeleteAll {
	mmDeleteAll.optional = true
	return mmDeleteAll
}

// Expect sets up expected params for CartRepository.DeleteAll
func (mmDeleteAll *mCartRepositoryMockDeleteAll) Expect(ctx context.Context, userId int64) *mCartRepositoryMockDeleteAll {
	if mmDeleteAll.mock.funcDeleteAll != nil {
		mmDeleteAll.mock.t.Fatalf("CartRepositoryMock.DeleteAll mock is already set by Set")
	}

	if mmDeleteAll.defaultExpectation == nil {
		mmDeleteAll.defaultExpectation = &CartRepositoryMockDeleteAllExpectation{}
	}

	if mmDeleteAll.defaultExpectation.paramPtrs != nil {
		mmDeleteAll.mock.t.Fatalf("CartRepositoryMock.DeleteAll mock is already set by ExpectParams functions")
	}

	mmDeleteAll.defaultExpectation.params = &CartRepositoryMockDeleteAllParams{ctx, userId}
	mmDeleteAll.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteAll.expectations {
		if minimock.Equal(e.params, mmDeleteAll.defaultExpectation.params) {
			mmDeleteAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteAll.defaultExpectation.params)
		}
	}

	return mmDeleteAll
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.DeleteAll
func (mmDeleteAll *mCartRepositoryMockDeleteAll) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockDeleteAll {
	if mmDeleteAll.mock.funcDeleteAll != nil {
		mmDeleteAll.mock.t.Fatalf("CartRepositoryMock.DeleteAll mock is already set by Set")
	}

	if mmDeleteAll.defaultExpectation == nil {
		mmDeleteAll.defaultExpectation = &CartRepositoryMockDeleteAllExpectation{}
	}

	if mmDeleteAll.defaultExpectation.params != nil {
		mmDeleteAll.mock.t.Fatalf("CartRepositoryMock.DeleteAll mock is already set by Expect")
	}

	if mmDeleteAll.defaultExpectation.paramPtrs == nil {
		mmDeleteAll.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteAllParamPtrs{}
	}
	mmDeleteAll.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteAll.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteAll
}

// ExpectUserIdParam2 sets up expected param userId for CartRepository.DeleteAll
func (mmDeleteAll *mCartRepositoryMockDeleteAll) ExpectUserIdParam2(userId int64) *mCartRepositoryMockDeleteAll {
	if mmDeleteAll.mock.funcDeleteAll != nil {
		mmDeleteAll.mock.t.Fatalf("CartRepositoryMock.DeleteAll mock is already set by Set")
	}

	if mmDeleteAll.defaultExpectation == nil {
		mmDeleteAll.defaultExpectation = &CartRepositoryMockDeleteAllExpectation{}
	}

	if mmDeleteAll.defaultExpectation.params != nil {
		mmDeleteAll.mock.t.Fatalf("CartRepositoryMock.DeleteAll mock is already set by Expect")
	}

	if mmDeleteAll.defaultExpectation.paramPtrs == nil {
		mmDeleteAll.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteAllParamPtrs{}
	}
	mmDeleteAll.defaultExpectation.paramPtrs.userId = &userId
	mmDeleteAll.defaultExpectation.expectationOrigins.originUserId = minimock.CallerInfo(1)

	return mmDeleteAll
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.DeleteAll
func (mmDeleteAll *mCartRepositoryMockDeleteAll) Inspect(f func(ctx context.Context, userId int64)) *mCartRepositoryMockDeleteAll {
	if mmDeleteAll.mock.inspectFuncDeleteAll != nil {
		mmDeleteAll.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.DeleteAll")
	}

	mmDeleteAll.mock.inspectFuncDeleteAll = f

	return mmDeleteAll
}

// Return sets up results that will be returned by CartRepository.DeleteAll
func (mmDeleteAll *mCartRepositoryMockDeleteAll) Return() *CartRepositoryMock {
	if mmDeleteAll.mock.funcDeleteAll != nil {
		mmDeleteAll.mock.t.Fatalf("CartRepositoryMock.DeleteAll mock is already set by Set")
	}

	if mmDeleteAll.defaultExpectation == nil {
		mmDeleteAll.defaultExpectation = &CartRepositoryMockDeleteAllExpectation{mock: mmDeleteAll.mock}
	}

	mmDeleteAll.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteAll.mock
}

// Set uses given function f to mock the CartRepository.DeleteAll method
func (mmDeleteAll *mCartRepositoryMockDeleteAll) Set(f func(ctx context.Context, userId int64)) *CartRepositoryMock {
	if mmDeleteAll.defaultExpectation != nil {
		mmDeleteAll.mock.t.Fatalf("Default expectation is already set for the CartRepository.DeleteAll method")
	}

	if len(mmDeleteAll.expectations) > 0 {
		mmDeleteAll.mock.t.Fatalf("Some expectations are already set for the CartRepository.DeleteAll method")
	}

	mmDeleteAll.mock.funcDeleteAll = f
	mmDeleteAll.mock.funcDeleteAllOrigin = minimock.CallerInfo(1)
	return mmDeleteAll.mock
}

// When sets expectation for the CartRepository.DeleteAll which will trigger the result defined by the following
// Then helper
func (mmDeleteAll *mCartRepositoryMockDeleteAll) When(ctx context.Context, userId int64) *CartRepositoryMockDeleteAllExpectation {
	if mmDeleteAll.mock.funcDeleteAll != nil {
		mmDeleteAll.mock.t.Fatalf("CartRepositoryMock.DeleteAll mock is already set by Set")
	}

	expectation := &CartRepositoryMockDeleteAllExpectation{
		mock:               mmDeleteAll.mock,
		params:             &CartRepositoryMockDeleteAllParams{ctx, userId},
		expectationOrigins: CartRepositoryMockDeleteAllExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteAll.expectations = append(mmDeleteAll.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.DeleteAll return parameters for the expectation previously defined by the When method

func (e *CartRepositoryMockDeleteAllExpectation) Then() *CartRepositoryMock {
	return e.mock
}

// Times sets number of times CartRepository.DeleteAll should be invoked
func (mmDeleteAll *mCartRepositoryMockDeleteAll) Times(n uint64) *mCartRepositoryMockDeleteAll {
	if n == 0 {
		mmDeleteAll.mock.t.Fatalf("Times of CartRepositoryMock.DeleteAll mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteAll.expectedInvocations, n)
	mmDeleteAll.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteAll
}

func (mmDeleteAll *mCartRepositoryMockDeleteAll) invocationsDone() bool {
	if len(mmDeleteAll.expectations) == 0 && mmDeleteAll.defaultExpectation == nil && mmDeleteAll.mock.funcDeleteAll == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteAll.mock.afterDeleteAllCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteAll.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteAll implements CartRepository
func (mmDeleteAll *CartRepositoryMock) DeleteAll(ctx context.Context, userId int64) {
	mm_atomic.AddUint64(&mmDeleteAll.beforeDeleteAllCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteAll.afterDeleteAllCounter, 1)

	mmDeleteAll.t.Helper()

	if mmDeleteAll.inspectFuncDeleteAll != nil {
		mmDeleteAll.inspectFuncDeleteAll(ctx, userId)
	}

	mm_params := CartRepositoryMockDeleteAllParams{ctx, userId}

	// Record call args
	mmDeleteAll.DeleteAllMock.mutex.Lock()
	mmDeleteAll.DeleteAllMock.callArgs = append(mmDeleteAll.DeleteAllMock.callArgs, &mm_params)
	mmDeleteAll.DeleteAllMock.mutex.Unlock()

	for _, e := range mmDeleteAll.DeleteAllMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDeleteAll.DeleteAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteAll.DeleteAllMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteAll.DeleteAllMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteAll.DeleteAllMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockDeleteAllParams{ctx, userId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteAll.t.Errorf("CartRepositoryMock.DeleteAll got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAll.DeleteAllMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmDeleteAll.t.Errorf("CartRepositoryMock.DeleteAll got unexpected parameter userId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAll.DeleteAllMock.defaultExpectation.expectationOrigins.originUserId, *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteAll.t.Errorf("CartRepositoryMock.DeleteAll got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteAll.DeleteAllMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDeleteAll.funcDeleteAll != nil {
		mmDeleteAll.funcDeleteAll(ctx, userId)
		return
	}
	mmDeleteAll.t.Fatalf("Unexpected call to CartRepositoryMock.DeleteAll. %v %v", ctx, userId)

}

// DeleteAllAfterCounter returns a count of finished CartRepositoryMock.DeleteAll invocations
func (mmDeleteAll *CartRepositoryMock) DeleteAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAll.afterDeleteAllCounter)
}

// DeleteAllBeforeCounter returns a count of CartRepositoryMock.DeleteAll invocations
func (mmDeleteAll *CartRepositoryMock) DeleteAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAll.beforeDeleteAllCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.DeleteAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteAll *mCartRepositoryMockDeleteAll) Calls() []*CartRepositoryMockDeleteAllParams {
	mmDeleteAll.mutex.RLock()

	argCopy := make([]*CartRepositoryMockDeleteAllParams, len(mmDeleteAll.callArgs))
	copy(argCopy, mmDeleteAll.callArgs)

	mmDeleteAll.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAllDone returns true if the count of the DeleteAll invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockDeleteAllDone() bool {
	if m.DeleteAllMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteAllMock.invocationsDone()
}

// MinimockDeleteAllInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockDeleteAllInspect() {
	for _, e := range m.DeleteAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteAll at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteAllCounter := mm_atomic.LoadUint64(&m.afterDeleteAllCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAllMock.defaultExpectation != nil && afterDeleteAllCounter < 1 {
		if m.DeleteAllMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteAll at\n%s", m.DeleteAllMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteAll at\n%s with params: %#v", m.DeleteAllMock.defaultExpectation.expectationOrigins.origin, *m.DeleteAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAll != nil && afterDeleteAllCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.DeleteAll at\n%s", m.funcDeleteAllOrigin)
	}

	if !m.DeleteAllMock.invocationsDone() && afterDeleteAllCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.DeleteAll at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteAllMock.expectedInvocations), m.DeleteAllMock.expectedInvocationsOrigin, afterDeleteAllCounter)
	}
}

type mCartRepositoryMockDeleteBySku struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockDeleteBySkuExpectation
	expectations       []*CartRepositoryMockDeleteBySkuExpectation

	callArgs []*CartRepositoryMockDeleteBySkuParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockDeleteBySkuExpectation specifies expectation struct of the CartRepository.DeleteBySku
type CartRepositoryMockDeleteBySkuExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockDeleteBySkuParams
	paramPtrs          *CartRepositoryMockDeleteBySkuParamPtrs
	expectationOrigins CartRepositoryMockDeleteBySkuExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// CartRepositoryMockDeleteBySkuParams contains parameters of the CartRepository.DeleteBySku
type CartRepositoryMockDeleteBySkuParams struct {
	ctx    context.Context
	userId int64
	skuId  int64
}

// CartRepositoryMockDeleteBySkuParamPtrs contains pointers to parameters of the CartRepository.DeleteBySku
type CartRepositoryMockDeleteBySkuParamPtrs struct {
	ctx    *context.Context
	userId *int64
	skuId  *int64
}

// CartRepositoryMockDeleteBySkuOrigins contains origins of expectations of the CartRepository.DeleteBySku
type CartRepositoryMockDeleteBySkuExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserId string
	originSkuId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteBySku *mCartRepositoryMockDeleteBySku) Optional() *mCartRepositoryMockDeleteBySku {
	mmDeleteBySku.optional = true
	return mmDeleteBySku
}

// Expect sets up expected params for CartRepository.DeleteBySku
func (mmDeleteBySku *mCartRepositoryMockDeleteBySku) Expect(ctx context.Context, userId int64, skuId int64) *mCartRepositoryMockDeleteBySku {
	if mmDeleteBySku.mock.funcDeleteBySku != nil {
		mmDeleteBySku.mock.t.Fatalf("CartRepositoryMock.DeleteBySku mock is already set by Set")
	}

	if mmDeleteBySku.defaultExpectation == nil {
		mmDeleteBySku.defaultExpectation = &CartRepositoryMockDeleteBySkuExpectation{}
	}

	if mmDeleteBySku.defaultExpectation.paramPtrs != nil {
		mmDeleteBySku.mock.t.Fatalf("CartRepositoryMock.DeleteBySku mock is already set by ExpectParams functions")
	}

	mmDeleteBySku.defaultExpectation.params = &CartRepositoryMockDeleteBySkuParams{ctx, userId, skuId}
	mmDeleteBySku.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteBySku.expectations {
		if minimock.Equal(e.params, mmDeleteBySku.defaultExpectation.params) {
			mmDeleteBySku.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteBySku.defaultExpectation.params)
		}
	}

	return mmDeleteBySku
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.DeleteBySku
func (mmDeleteBySku *mCartRepositoryMockDeleteBySku) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockDeleteBySku {
	if mmDeleteBySku.mock.funcDeleteBySku != nil {
		mmDeleteBySku.mock.t.Fatalf("CartRepositoryMock.DeleteBySku mock is already set by Set")
	}

	if mmDeleteBySku.defaultExpectation == nil {
		mmDeleteBySku.defaultExpectation = &CartRepositoryMockDeleteBySkuExpectation{}
	}

	if mmDeleteBySku.defaultExpectation.params != nil {
		mmDeleteBySku.mock.t.Fatalf("CartRepositoryMock.DeleteBySku mock is already set by Expect")
	}

	if mmDeleteBySku.defaultExpectation.paramPtrs == nil {
		mmDeleteBySku.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteBySkuParamPtrs{}
	}
	mmDeleteBySku.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteBySku.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteBySku
}

// ExpectUserIdParam2 sets up expected param userId for CartRepository.DeleteBySku
func (mmDeleteBySku *mCartRepositoryMockDeleteBySku) ExpectUserIdParam2(userId int64) *mCartRepositoryMockDeleteBySku {
	if mmDeleteBySku.mock.funcDeleteBySku != nil {
		mmDeleteBySku.mock.t.Fatalf("CartRepositoryMock.DeleteBySku mock is already set by Set")
	}

	if mmDeleteBySku.defaultExpectation == nil {
		mmDeleteBySku.defaultExpectation = &CartRepositoryMockDeleteBySkuExpectation{}
	}

	if mmDeleteBySku.defaultExpectation.params != nil {
		mmDeleteBySku.mock.t.Fatalf("CartRepositoryMock.DeleteBySku mock is already set by Expect")
	}

	if mmDeleteBySku.defaultExpectation.paramPtrs == nil {
		mmDeleteBySku.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteBySkuParamPtrs{}
	}
	mmDeleteBySku.defaultExpectation.paramPtrs.userId = &userId
	mmDeleteBySku.defaultExpectation.expectationOrigins.originUserId = minimock.CallerInfo(1)

	return mmDeleteBySku
}

// ExpectSkuIdParam3 sets up expected param skuId for CartRepository.DeleteBySku
func (mmDeleteBySku *mCartRepositoryMockDeleteBySku) ExpectSkuIdParam3(skuId int64) *mCartRepositoryMockDeleteBySku {
	if mmDeleteBySku.mock.funcDeleteBySku != nil {
		mmDeleteBySku.mock.t.Fatalf("CartRepositoryMock.DeleteBySku mock is already set by Set")
	}

	if mmDeleteBySku.defaultExpectation == nil {
		mmDeleteBySku.defaultExpectation = &CartRepositoryMockDeleteBySkuExpectation{}
	}

	if mmDeleteBySku.defaultExpectation.params != nil {
		mmDeleteBySku.mock.t.Fatalf("CartRepositoryMock.DeleteBySku mock is already set by Expect")
	}

	if mmDeleteBySku.defaultExpectation.paramPtrs == nil {
		mmDeleteBySku.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteBySkuParamPtrs{}
	}
	mmDeleteBySku.defaultExpectation.paramPtrs.skuId = &skuId
	mmDeleteBySku.defaultExpectation.expectationOrigins.originSkuId = minimock.CallerInfo(1)

	return mmDeleteBySku
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.DeleteBySku
func (mmDeleteBySku *mCartRepositoryMockDeleteBySku) Inspect(f func(ctx context.Context, userId int64, skuId int64)) *mCartRepositoryMockDeleteBySku {
	if mmDeleteBySku.mock.inspectFuncDeleteBySku != nil {
		mmDeleteBySku.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.DeleteBySku")
	}

	mmDeleteBySku.mock.inspectFuncDeleteBySku = f

	return mmDeleteBySku
}

// Return sets up results that will be returned by CartRepository.DeleteBySku
func (mmDeleteBySku *mCartRepositoryMockDeleteBySku) Return() *CartRepositoryMock {
	if mmDeleteBySku.mock.funcDeleteBySku != nil {
		mmDeleteBySku.mock.t.Fatalf("CartRepositoryMock.DeleteBySku mock is already set by Set")
	}

	if mmDeleteBySku.defaultExpectation == nil {
		mmDeleteBySku.defaultExpectation = &CartRepositoryMockDeleteBySkuExpectation{mock: mmDeleteBySku.mock}
	}

	mmDeleteBySku.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteBySku.mock
}

// Set uses given function f to mock the CartRepository.DeleteBySku method
func (mmDeleteBySku *mCartRepositoryMockDeleteBySku) Set(f func(ctx context.Context, userId int64, skuId int64)) *CartRepositoryMock {
	if mmDeleteBySku.defaultExpectation != nil {
		mmDeleteBySku.mock.t.Fatalf("Default expectation is already set for the CartRepository.DeleteBySku method")
	}

	if len(mmDeleteBySku.expectations) > 0 {
		mmDeleteBySku.mock.t.Fatalf("Some expectations are already set for the CartRepository.DeleteBySku method")
	}

	mmDeleteBySku.mock.funcDeleteBySku = f
	mmDeleteBySku.mock.funcDeleteBySkuOrigin = minimock.CallerInfo(1)
	return mmDeleteBySku.mock
}

// When sets expectation for the CartRepository.DeleteBySku which will trigger the result defined by the following
// Then helper
func (mmDeleteBySku *mCartRepositoryMockDeleteBySku) When(ctx context.Context, userId int64, skuId int64) *CartRepositoryMockDeleteBySkuExpectation {
	if mmDeleteBySku.mock.funcDeleteBySku != nil {
		mmDeleteBySku.mock.t.Fatalf("CartRepositoryMock.DeleteBySku mock is already set by Set")
	}

	expectation := &CartRepositoryMockDeleteBySkuExpectation{
		mock:               mmDeleteBySku.mock,
		params:             &CartRepositoryMockDeleteBySkuParams{ctx, userId, skuId},
		expectationOrigins: CartRepositoryMockDeleteBySkuExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteBySku.expectations = append(mmDeleteBySku.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.DeleteBySku return parameters for the expectation previously defined by the When method

func (e *CartRepositoryMockDeleteBySkuExpectation) Then() *CartRepositoryMock {
	return e.mock
}

// Times sets number of times CartRepository.DeleteBySku should be invoked
func (mmDeleteBySku *mCartRepositoryMockDeleteBySku) Times(n uint64) *mCartRepositoryMockDeleteBySku {
	if n == 0 {
		mmDeleteBySku.mock.t.Fatalf("Times of CartRepositoryMock.DeleteBySku mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteBySku.expectedInvocations, n)
	mmDeleteBySku.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteBySku
}

func (mmDeleteBySku *mCartRepositoryMockDeleteBySku) invocationsDone() bool {
	if len(mmDeleteBySku.expectations) == 0 && mmDeleteBySku.defaultExpectation == nil && mmDeleteBySku.mock.funcDeleteBySku == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteBySku.mock.afterDeleteBySkuCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteBySku.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteBySku implements CartRepository
func (mmDeleteBySku *CartRepositoryMock) DeleteBySku(ctx context.Context, userId int64, skuId int64) {
	mm_atomic.AddUint64(&mmDeleteBySku.beforeDeleteBySkuCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteBySku.afterDeleteBySkuCounter, 1)

	mmDeleteBySku.t.Helper()

	if mmDeleteBySku.inspectFuncDeleteBySku != nil {
		mmDeleteBySku.inspectFuncDeleteBySku(ctx, userId, skuId)
	}

	mm_params := CartRepositoryMockDeleteBySkuParams{ctx, userId, skuId}

	// Record call args
	mmDeleteBySku.DeleteBySkuMock.mutex.Lock()
	mmDeleteBySku.DeleteBySkuMock.callArgs = append(mmDeleteBySku.DeleteBySkuMock.callArgs, &mm_params)
	mmDeleteBySku.DeleteBySkuMock.mutex.Unlock()

	for _, e := range mmDeleteBySku.DeleteBySkuMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDeleteBySku.DeleteBySkuMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteBySku.DeleteBySkuMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteBySku.DeleteBySkuMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteBySku.DeleteBySkuMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockDeleteBySkuParams{ctx, userId, skuId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteBySku.t.Errorf("CartRepositoryMock.DeleteBySku got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteBySku.DeleteBySkuMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmDeleteBySku.t.Errorf("CartRepositoryMock.DeleteBySku got unexpected parameter userId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteBySku.DeleteBySkuMock.defaultExpectation.expectationOrigins.originUserId, *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

			if mm_want_ptrs.skuId != nil && !minimock.Equal(*mm_want_ptrs.skuId, mm_got.skuId) {
				mmDeleteBySku.t.Errorf("CartRepositoryMock.DeleteBySku got unexpected parameter skuId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteBySku.DeleteBySkuMock.defaultExpectation.expectationOrigins.originSkuId, *mm_want_ptrs.skuId, mm_got.skuId, minimock.Diff(*mm_want_ptrs.skuId, mm_got.skuId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteBySku.t.Errorf("CartRepositoryMock.DeleteBySku got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteBySku.DeleteBySkuMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDeleteBySku.funcDeleteBySku != nil {
		mmDeleteBySku.funcDeleteBySku(ctx, userId, skuId)
		return
	}
	mmDeleteBySku.t.Fatalf("Unexpected call to CartRepositoryMock.DeleteBySku. %v %v %v", ctx, userId, skuId)

}

// DeleteBySkuAfterCounter returns a count of finished CartRepositoryMock.DeleteBySku invocations
func (mmDeleteBySku *CartRepositoryMock) DeleteBySkuAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteBySku.afterDeleteBySkuCounter)
}

// DeleteBySkuBeforeCounter returns a count of CartRepositoryMock.DeleteBySku invocations
func (mmDeleteBySku *CartRepositoryMock) DeleteBySkuBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteBySku.beforeDeleteBySkuCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.DeleteBySku.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteBySku *mCartRepositoryMockDeleteBySku) Calls() []*CartRepositoryMockDeleteBySkuParams {
	mmDeleteBySku.mutex.RLock()

	argCopy := make([]*CartRepositoryMockDeleteBySkuParams, len(mmDeleteBySku.callArgs))
	copy(argCopy, mmDeleteBySku.callArgs)

	mmDeleteBySku.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteBySkuDone returns true if the count of the DeleteBySku invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockDeleteBySkuDone() bool {
	if m.DeleteBySkuMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteBySkuMock.invocationsDone()
}

// MinimockDeleteBySkuInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockDeleteBySkuInspect() {
	for _, e := range m.DeleteBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteBySku at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteBySkuCounter := mm_atomic.LoadUint64(&m.afterDeleteBySkuCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteBySkuMock.defaultExpectation != nil && afterDeleteBySkuCounter < 1 {
		if m.DeleteBySkuMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteBySku at\n%s", m.DeleteBySkuMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteBySku at\n%s with params: %#v", m.DeleteBySkuMock.defaultExpectation.expectationOrigins.origin, *m.DeleteBySkuMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteBySku != nil && afterDeleteBySkuCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.DeleteBySku at\n%s", m.funcDeleteBySkuOrigin)
	}

	if !m.DeleteBySkuMock.invocationsDone() && afterDeleteBySkuCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.DeleteBySku at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteBySkuMock.expectedInvocations), m.DeleteBySkuMock.expectedInvocationsOrigin, afterDeleteBySkuCounter)
	}
}

type mCartRepositoryMockGetAllOrderBySku struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockGetAllOrderBySkuExpectation
	expectations       []*CartRepositoryMockGetAllOrderBySkuExpectation

	callArgs []*CartRepositoryMockGetAllOrderBySkuParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockGetAllOrderBySkuExpectation specifies expectation struct of the CartRepository.GetAllOrderBySku
type CartRepositoryMockGetAllOrderBySkuExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockGetAllOrderBySkuParams
	paramPtrs          *CartRepositoryMockGetAllOrderBySkuParamPtrs
	expectationOrigins CartRepositoryMockGetAllOrderBySkuExpectationOrigins
	results            *CartRepositoryMockGetAllOrderBySkuResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockGetAllOrderBySkuParams contains parameters of the CartRepository.GetAllOrderBySku
type CartRepositoryMockGetAllOrderBySkuParams struct {
	ctx    context.Context
	userId int64
}

// CartRepositoryMockGetAllOrderBySkuParamPtrs contains pointers to parameters of the CartRepository.GetAllOrderBySku
type CartRepositoryMockGetAllOrderBySkuParamPtrs struct {
	ctx    *context.Context
	userId *int64
}

// CartRepositoryMockGetAllOrderBySkuResults contains results of the CartRepository.GetAllOrderBySku
type CartRepositoryMockGetAllOrderBySkuResults struct {
	ca1 []model.CartItemModel
}

// CartRepositoryMockGetAllOrderBySkuOrigins contains origins of expectations of the CartRepository.GetAllOrderBySku
type CartRepositoryMockGetAllOrderBySkuExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAllOrderBySku *mCartRepositoryMockGetAllOrderBySku) Optional() *mCartRepositoryMockGetAllOrderBySku {
	mmGetAllOrderBySku.optional = true
	return mmGetAllOrderBySku
}

// Expect sets up expected params for CartRepository.GetAllOrderBySku
func (mmGetAllOrderBySku *mCartRepositoryMockGetAllOrderBySku) Expect(ctx context.Context, userId int64) *mCartRepositoryMockGetAllOrderBySku {
	if mmGetAllOrderBySku.mock.funcGetAllOrderBySku != nil {
		mmGetAllOrderBySku.mock.t.Fatalf("CartRepositoryMock.GetAllOrderBySku mock is already set by Set")
	}

	if mmGetAllOrderBySku.defaultExpectation == nil {
		mmGetAllOrderBySku.defaultExpectation = &CartRepositoryMockGetAllOrderBySkuExpectation{}
	}

	if mmGetAllOrderBySku.defaultExpectation.paramPtrs != nil {
		mmGetAllOrderBySku.mock.t.Fatalf("CartRepositoryMock.GetAllOrderBySku mock is already set by ExpectParams functions")
	}

	mmGetAllOrderBySku.defaultExpectation.params = &CartRepositoryMockGetAllOrderBySkuParams{ctx, userId}
	mmGetAllOrderBySku.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAllOrderBySku.expectations {
		if minimock.Equal(e.params, mmGetAllOrderBySku.defaultExpectation.params) {
			mmGetAllOrderBySku.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAllOrderBySku.defaultExpectation.params)
		}
	}

	return mmGetAllOrderBySku
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.GetAllOrderBySku
func (mmGetAllOrderBySku *mCartRepositoryMockGetAllOrderBySku) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockGetAllOrderBySku {
	if mmGetAllOrderBySku.mock.funcGetAllOrderBySku != nil {
		mmGetAllOrderBySku.mock.t.Fatalf("CartRepositoryMock.GetAllOrderBySku mock is already set by Set")
	}

	if mmGetAllOrderBySku.defaultExpectation == nil {
		mmGetAllOrderBySku.defaultExpectation = &CartRepositoryMockGetAllOrderBySkuExpectation{}
	}

	if mmGetAllOrderBySku.defaultExpectation.params != nil {
		mmGetAllOrderBySku.mock.t.Fatalf("CartRepositoryMock.GetAllOrderBySku mock is already set by Expect")
	}

	if mmGetAllOrderBySku.defaultExpectation.paramPtrs == nil {
		mmGetAllOrderBySku.defaultExpectation.paramPtrs = &CartRepositoryMockGetAllOrderBySkuParamPtrs{}
	}
	mmGetAllOrderBySku.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAllOrderBySku.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAllOrderBySku
}

// ExpectUserIdParam2 sets up expected param userId for CartRepository.GetAllOrderBySku
func (mmGetAllOrderBySku *mCartRepositoryMockGetAllOrderBySku) ExpectUserIdParam2(userId int64) *mCartRepositoryMockGetAllOrderBySku {
	if mmGetAllOrderBySku.mock.funcGetAllOrderBySku != nil {
		mmGetAllOrderBySku.mock.t.Fatalf("CartRepositoryMock.GetAllOrderBySku mock is already set by Set")
	}

	if mmGetAllOrderBySku.defaultExpectation == nil {
		mmGetAllOrderBySku.defaultExpectation = &CartRepositoryMockGetAllOrderBySkuExpectation{}
	}

	if mmGetAllOrderBySku.defaultExpectation.params != nil {
		mmGetAllOrderBySku.mock.t.Fatalf("CartRepositoryMock.GetAllOrderBySku mock is already set by Expect")
	}

	if mmGetAllOrderBySku.defaultExpectation.paramPtrs == nil {
		mmGetAllOrderBySku.defaultExpectation.paramPtrs = &CartRepositoryMockGetAllOrderBySkuParamPtrs{}
	}
	mmGetAllOrderBySku.defaultExpectation.paramPtrs.userId = &userId
	mmGetAllOrderBySku.defaultExpectation.expectationOrigins.originUserId = minimock.CallerInfo(1)

	return mmGetAllOrderBySku
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.GetAllOrderBySku
func (mmGetAllOrderBySku *mCartRepositoryMockGetAllOrderBySku) Inspect(f func(ctx context.Context, userId int64)) *mCartRepositoryMockGetAllOrderBySku {
	if mmGetAllOrderBySku.mock.inspectFuncGetAllOrderBySku != nil {
		mmGetAllOrderBySku.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.GetAllOrderBySku")
	}

	mmGetAllOrderBySku.mock.inspectFuncGetAllOrderBySku = f

	return mmGetAllOrderBySku
}

// Return sets up results that will be returned by CartRepository.GetAllOrderBySku
func (mmGetAllOrderBySku *mCartRepositoryMockGetAllOrderBySku) Return(ca1 []model.CartItemModel) *CartRepositoryMock {
	if mmGetAllOrderBySku.mock.funcGetAllOrderBySku != nil {
		mmGetAllOrderBySku.mock.t.Fatalf("CartRepositoryMock.GetAllOrderBySku mock is already set by Set")
	}

	if mmGetAllOrderBySku.defaultExpectation == nil {
		mmGetAllOrderBySku.defaultExpectation = &CartRepositoryMockGetAllOrderBySkuExpectation{mock: mmGetAllOrderBySku.mock}
	}
	mmGetAllOrderBySku.defaultExpectation.results = &CartRepositoryMockGetAllOrderBySkuResults{ca1}
	mmGetAllOrderBySku.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAllOrderBySku.mock
}

// Set uses given function f to mock the CartRepository.GetAllOrderBySku method
func (mmGetAllOrderBySku *mCartRepositoryMockGetAllOrderBySku) Set(f func(ctx context.Context, userId int64) (ca1 []model.CartItemModel)) *CartRepositoryMock {
	if mmGetAllOrderBySku.defaultExpectation != nil {
		mmGetAllOrderBySku.mock.t.Fatalf("Default expectation is already set for the CartRepository.GetAllOrderBySku method")
	}

	if len(mmGetAllOrderBySku.expectations) > 0 {
		mmGetAllOrderBySku.mock.t.Fatalf("Some expectations are already set for the CartRepository.GetAllOrderBySku method")
	}

	mmGetAllOrderBySku.mock.funcGetAllOrderBySku = f
	mmGetAllOrderBySku.mock.funcGetAllOrderBySkuOrigin = minimock.CallerInfo(1)
	return mmGetAllOrderBySku.mock
}

// When sets expectation for the CartRepository.GetAllOrderBySku which will trigger the result defined by the following
// Then helper
func (mmGetAllOrderBySku *mCartRepositoryMockGetAllOrderBySku) When(ctx context.Context, userId int64) *CartRepositoryMockGetAllOrderBySkuExpectation {
	if mmGetAllOrderBySku.mock.funcGetAllOrderBySku != nil {
		mmGetAllOrderBySku.mock.t.Fatalf("CartRepositoryMock.GetAllOrderBySku mock is already set by Set")
	}

	expectation := &CartRepositoryMockGetAllOrderBySkuExpectation{
		mock:               mmGetAllOrderBySku.mock,
		params:             &CartRepositoryMockGetAllOrderBySkuParams{ctx, userId},
		expectationOrigins: CartRepositoryMockGetAllOrderBySkuExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAllOrderBySku.expectations = append(mmGetAllOrderBySku.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.GetAllOrderBySku return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockGetAllOrderBySkuExpectation) Then(ca1 []model.CartItemModel) *CartRepositoryMock {
	e.results = &CartRepositoryMockGetAllOrderBySkuResults{ca1}
	return e.mock
}

// Times sets number of times CartRepository.GetAllOrderBySku should be invoked
func (mmGetAllOrderBySku *mCartRepositoryMockGetAllOrderBySku) Times(n uint64) *mCartRepositoryMockGetAllOrderBySku {
	if n == 0 {
		mmGetAllOrderBySku.mock.t.Fatalf("Times of CartRepositoryMock.GetAllOrderBySku mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAllOrderBySku.expectedInvocations, n)
	mmGetAllOrderBySku.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAllOrderBySku
}

func (mmGetAllOrderBySku *mCartRepositoryMockGetAllOrderBySku) invocationsDone() bool {
	if len(mmGetAllOrderBySku.expectations) == 0 && mmGetAllOrderBySku.defaultExpectation == nil && mmGetAllOrderBySku.mock.funcGetAllOrderBySku == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAllOrderBySku.mock.afterGetAllOrderBySkuCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAllOrderBySku.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAllOrderBySku implements CartRepository
func (mmGetAllOrderBySku *CartRepositoryMock) GetAllOrderBySku(ctx context.Context, userId int64) (ca1 []model.CartItemModel) {
	mm_atomic.AddUint64(&mmGetAllOrderBySku.beforeGetAllOrderBySkuCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAllOrderBySku.afterGetAllOrderBySkuCounter, 1)

	mmGetAllOrderBySku.t.Helper()

	if mmGetAllOrderBySku.inspectFuncGetAllOrderBySku != nil {
		mmGetAllOrderBySku.inspectFuncGetAllOrderBySku(ctx, userId)
	}

	mm_params := CartRepositoryMockGetAllOrderBySkuParams{ctx, userId}

	// Record call args
	mmGetAllOrderBySku.GetAllOrderBySkuMock.mutex.Lock()
	mmGetAllOrderBySku.GetAllOrderBySkuMock.callArgs = append(mmGetAllOrderBySku.GetAllOrderBySkuMock.callArgs, &mm_params)
	mmGetAllOrderBySku.GetAllOrderBySkuMock.mutex.Unlock()

	for _, e := range mmGetAllOrderBySku.GetAllOrderBySkuMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1
		}
	}

	if mmGetAllOrderBySku.GetAllOrderBySkuMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAllOrderBySku.GetAllOrderBySkuMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAllOrderBySku.GetAllOrderBySkuMock.defaultExpectation.params
		mm_want_ptrs := mmGetAllOrderBySku.GetAllOrderBySkuMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockGetAllOrderBySkuParams{ctx, userId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAllOrderBySku.t.Errorf("CartRepositoryMock.GetAllOrderBySku got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAllOrderBySku.GetAllOrderBySkuMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmGetAllOrderBySku.t.Errorf("CartRepositoryMock.GetAllOrderBySku got unexpected parameter userId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAllOrderBySku.GetAllOrderBySkuMock.defaultExpectation.expectationOrigins.originUserId, *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAllOrderBySku.t.Errorf("CartRepositoryMock.GetAllOrderBySku got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAllOrderBySku.GetAllOrderBySkuMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAllOrderBySku.GetAllOrderBySkuMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAllOrderBySku.t.Fatal("No results are set for the CartRepositoryMock.GetAllOrderBySku")
		}
		return (*mm_results).ca1
	}
	if mmGetAllOrderBySku.funcGetAllOrderBySku != nil {
		return mmGetAllOrderBySku.funcGetAllOrderBySku(ctx, userId)
	}
	mmGetAllOrderBySku.t.Fatalf("Unexpected call to CartRepositoryMock.GetAllOrderBySku. %v %v", ctx, userId)
	return
}

// GetAllOrderBySkuAfterCounter returns a count of finished CartRepositoryMock.GetAllOrderBySku invocations
func (mmGetAllOrderBySku *CartRepositoryMock) GetAllOrderBySkuAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllOrderBySku.afterGetAllOrderBySkuCounter)
}

// GetAllOrderBySkuBeforeCounter returns a count of CartRepositoryMock.GetAllOrderBySku invocations
func (mmGetAllOrderBySku *CartRepositoryMock) GetAllOrderBySkuBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllOrderBySku.beforeGetAllOrderBySkuCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.GetAllOrderBySku.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAllOrderBySku *mCartRepositoryMockGetAllOrderBySku) Calls() []*CartRepositoryMockGetAllOrderBySkuParams {
	mmGetAllOrderBySku.mutex.RLock()

	argCopy := make([]*CartRepositoryMockGetAllOrderBySkuParams, len(mmGetAllOrderBySku.callArgs))
	copy(argCopy, mmGetAllOrderBySku.callArgs)

	mmGetAllOrderBySku.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllOrderBySkuDone returns true if the count of the GetAllOrderBySku invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockGetAllOrderBySkuDone() bool {
	if m.GetAllOrderBySkuMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAllOrderBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAllOrderBySkuMock.invocationsDone()
}

// MinimockGetAllOrderBySkuInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockGetAllOrderBySkuInspect() {
	for _, e := range m.GetAllOrderBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.GetAllOrderBySku at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAllOrderBySkuCounter := mm_atomic.LoadUint64(&m.afterGetAllOrderBySkuCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllOrderBySkuMock.defaultExpectation != nil && afterGetAllOrderBySkuCounter < 1 {
		if m.GetAllOrderBySkuMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.GetAllOrderBySku at\n%s", m.GetAllOrderBySkuMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.GetAllOrderBySku at\n%s with params: %#v", m.GetAllOrderBySkuMock.defaultExpectation.expectationOrigins.origin, *m.GetAllOrderBySkuMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllOrderBySku != nil && afterGetAllOrderBySkuCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.GetAllOrderBySku at\n%s", m.funcGetAllOrderBySkuOrigin)
	}

	if !m.GetAllOrderBySkuMock.invocationsDone() && afterGetAllOrderBySkuCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.GetAllOrderBySku at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAllOrderBySkuMock.expectedInvocations), m.GetAllOrderBySkuMock.expectedInvocationsOrigin, afterGetAllOrderBySkuCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateItemInspect()

			m.MinimockDeleteAllInspect()

			m.MinimockDeleteBySkuInspect()

			m.MinimockGetAllOrderBySkuInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateItemDone() &&
		m.MinimockDeleteAllDone() &&
		m.MinimockDeleteBySkuDone() &&
		m.MinimockGetAllOrderBySkuDone()
}
